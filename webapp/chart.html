<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Live Chart</title>
    
    <!-- Telegram WebApp SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- Lightweight Charts Library v5.0 -->
    <script src="https://unpkg.com/lightweight-charts@5.0.0/dist/lightweight-charts.standalone.production.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            overflow: hidden;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        #loading.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        .spinner {
            border: 4px solid rgba(54, 60, 78, 0.3);  /* TradingView grid color */
            border-top: 4px solid #2962FF;  /* TradingView blue */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #header {
            background: #1E222D;  /* TradingView panel BG */
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #2A2E39;  /* TradingView border */
            height: 48px;
        }
        
        #symbol {
            font-size: 14px;
            font-weight: 600;
            color: #D1D4DC;  /* TradingView text */
            letter-spacing: -0.02em;
        }
        
        #price {
            font-size: 14px;
            font-weight: 600;
            font-variant-numeric: tabular-nums;  /* Monospace numbers */
        }
        
        .price-up { color: #26A69A; }  /* TradingView green */
        .price-down { color: #EF5350; }  /* TradingView red */
        
        #timeframes {
            background: #252525;
            padding: 8px;
            display: flex;
            gap: 8px;
            border-bottom: 1px solid #333;
            overflow-x: auto;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }
        
        #timeframes::-webkit-scrollbar {
            height: 4px;
        }
        
        #timeframes::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        #timeframes::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 2px;
        }
        
        .tf-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #333;
            color: #aaa;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .tf-btn:active {
            transform: scale(0.95);
        }
        
        .tf-btn.active {
            background: #2196F3;
            color: #fff;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.4);
        }
        
        .tf-btn:hover:not(.active) {
            background: #404040;
            color: #fff;
        }
        
        #chartContainer {
            width: 100%;
            height: calc(100vh - 110px);
            position: relative;
            touch-action: pan-x pan-y;
            -webkit-user-select: none;
            user-select: none;
        }
        
        #indicators {
            position: absolute;
            top: 120px;
            left: 10px;
            background: rgba(37, 37, 37, 0.90);
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 13px;
            z-index: 1;  /* Lower z-index to not block chart interactions */
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 180px;
            pointer-events: none;  /* Don't block chart touch events */
            transition: opacity 0.3s ease;
        }
        
        /* Make children interactive */
        #indicators * {
            pointer-events: auto;
        }
        
        /* Auto-hide on interaction (TradingView pattern) */
        body.chart-interacting #indicators {
            opacity: 0.3;
        }
        
        .indicator-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 6px 0;
            gap: 12px;
        }
        
        .indicator-label {
            color: #bbb;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .indicator-value {
            font-weight: 700;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        /* RSI Colors based on zones */
        .rsi-oversold { color: #26A69A; }  /* Green - Buy zone */
        .rsi-neutral { color: #2962FF; }    /* Blue - Neutral */
        .rsi-overbought { color: #EF5350; } /* Red - Sell zone */
        
        /* MFI Colors based on zones */
        .mfi-oversold { color: #26A69A; }   /* Green - Buy zone */
        .mfi-neutral { color: #FF6D00; }     /* Orange - Neutral */
        .mfi-overbought { color: #EF5350; }  /* Red - Sell zone */
        
        /* Trend arrows - Reduced animation */
        .trend-arrow {
            font-size: 16px;
            display: inline-block;
        }
        
        .trend-up { color: #26A69A; }
        .trend-down { color: #EF5350; }
        .trend-neutral { color: #777; opacity: 0.5; }
        
        /* Optional subtle animation for important signals only */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.85; }
        }
        
        /* Signal badge - Move to left side, below indicators */
        .signal-badge {
            position: absolute;
            top: 340px;  /* Below indicators panel (120px top + ~200px height) */
            left: 10px;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 14px;
            z-index: 1;
            backdrop-filter: blur(8px);
            border: 2px solid;
        }
        
        .signal-buy {
            background: rgba(38, 166, 154, 0.2);
            color: #26A69A;
            border-color: #26A69A;
        }
        
        .signal-sell {
            background: rgba(239, 83, 80, 0.2);
            color: #EF5350;
            border-color: #EF5350;
        }
        
        .signal-neutral {
            background: rgba(119, 119, 119, 0.2);
            color: #aaa;
            border-color: #777;
        }
        
        /* ============================================================
           OHLCV LEGEND (Phase 2: TradingView-style legend)
           ============================================================ */
        #ohlcv-legend {
            position: absolute;
            right: 12px;  /* Move to right side to avoid blocking indicators */
            top: 60px;  /* Below header */
            z-index: 2;
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            pointer-events: none;
            transition: opacity 0.2s ease;
            background: rgba(30, 34, 45, 0.85);  /* TradingView panel with transparency */
            border-radius: 6px;
            padding: 8px 12px;
            border: 1px solid rgba(42, 46, 57, 0.5);
            backdrop-filter: blur(8px);
        }
        
        #ohlcv-legend.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        .legend-symbol {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 6px;
            letter-spacing: -0.02em;
            color: #D1D4DC;
        }
        
        .legend-ohlcv {
            font-size: 11px;
            font-variant-numeric: tabular-nums;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            line-height: 16px;
        }
        
        .legend-item {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        
        .legend-label {
            color: #787B86;  /* TradingView secondary text */
            font-weight: 500;
        }
        
        .legend-value {
            color: #D1D4DC;  /* TradingView primary text */
            font-weight: 400;
        }
        
        .legend-change {
            font-weight: 600;
            margin-left: 4px;
        }
        
        .legend-change.positive {
            color: #26A69A;  /* TradingView green */
        }
        
        .legend-change.negative {
            color: #EF5350;  /* TradingView red */
        }
        
        /* Mobile compact legend */
        @media (max-width: 567px) {
            #ohlcv-legend {
                right: 8px;  /* Keep on right side on mobile */
                top: 52px;
                font-size: 10px;
                padding: 6px 10px;
            }
            
            .legend-symbol {
                font-size: 12px;
                margin-bottom: 4px;
            }
            
            .legend-ohlcv {
                font-size: 10px;
                gap: 8px;
            }
            
            /* Move signal badge higher on mobile to avoid blocking chart */
            .signal-badge {
                top: 300px;
                left: 8px;
                font-size: 12px;
                padding: 6px 12px;
            }
        }
        
        /* Zone indicator dots - No animation */
        .zone-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }
        
        /* Disable animations on low-end devices (TradingView best practice) */
        @media (prefers-reduced-motion: reduce) {
            .trend-arrow,
            .signal-badge,
            .zone-dot,
            #indicators {
                animation: none !important;
            }
        }
        
        #error {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #EF5350;
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            max-width: 80%;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div>Loading chart...</div>
    </div>
    
    <div id="error"></div>
    
    <div id="header">
        <div id="symbol">Loading...</div>
        <div id="price">--</div>
    </div>
    
    <div id="timeframes">
        <button class="tf-btn" data-tf="5m">5M</button>
        <button class="tf-btn active" data-tf="1h">1H</button>
        <button class="tf-btn" data-tf="4h">4H</button>
        <button class="tf-btn" data-tf="1d">1D</button>
    </div>
    
    <div id="signal-badge" class="signal-badge signal-neutral" style="display: none;">
        NEUTRAL
    </div>
    
    <!-- OHLCV Legend (Phase 2) -->
    <div id="ohlcv-legend">
        <div class="legend-symbol" id="legend-symbol">BTCUSDT</div>
        <div class="legend-ohlcv">
            <div class="legend-item">
                <span class="legend-label">O</span>
                <span class="legend-value" id="legend-open">--</span>
            </div>
            <div class="legend-item">
                <span class="legend-label">H</span>
                <span class="legend-value" id="legend-high">--</span>
            </div>
            <div class="legend-item">
                <span class="legend-label">L</span>
                <span class="legend-value" id="legend-low">--</span>
            </div>
            <div class="legend-item">
                <span class="legend-label">C</span>
                <span class="legend-value" id="legend-close">--</span>
            </div>
            <div class="legend-item">
                <span class="legend-change" id="legend-change">--</span>
            </div>
        </div>
    </div>
    
    <div id="indicators">
        <div class="indicator-row">
            <span class="indicator-label">
                <span class="zone-dot" id="rsi-dot" style="background: #777;"></span>
                RSI(14)
            </span>
            <span class="indicator-value" id="rsi-value">--</span>
        </div>
        <div class="indicator-row">
            <span class="indicator-label">
                <span class="zone-dot" id="mfi-dot" style="background: #777;"></span>
                MFI(14)
            </span>
            <span class="indicator-value" id="mfi-value">--</span>
        </div>
        <div class="indicator-row" style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 6px; margin-top: 6px;">
            <span class="indicator-label">Signal:</span>
            <span class="indicator-value" id="signal-text" style="font-size: 13px; color: #aaa;">--</span>
        </div>
    </div>
    
    <div id="chartContainer"></div>
    
    <script>
        // Initialize Telegram WebApp
        const tg = window.Telegram.WebApp;
        
        console.log('=== CHART INITIALIZATION START ===');
        console.log('Telegram WebApp:', tg);
        console.log('LightweightCharts available:', typeof LightweightCharts !== 'undefined');
        console.log('Platform:', tg.platform);
        console.log('Version:', tg.version);
        
        // Check if LightweightCharts is loaded
        if (typeof LightweightCharts === 'undefined') {
            console.error('‚ùå LightweightCharts library not loaded!');
            document.getElementById('loading').innerHTML = `
                <div style="color: red; padding: 20px; text-align: center;">
                    <h3>‚ö†Ô∏è Error Loading Chart Library</h3>
                    <p>LightweightCharts failed to load</p>
                    <button onclick="location.reload()">Reload</button>
                </div>
            `;
            throw new Error('LightweightCharts not loaded');
        }
        
        // Configure WebApp (Best Practices from docs)
        tg.ready();  // Signal that Mini App is ready
        tg.expand();  // Expand to maximum height
        
        // Enable vertical swipes (recommended by docs)
        if (tg.isVersionAtLeast('7.7')) {
            tg.enableVerticalSwipes();
        }
        
        // Apply Telegram theme
        if (tg.colorScheme === 'dark') {
            document.body.style.background = '#1a1a1a';
        }
        
        // Get parameters from URL
        const urlParams = new URLSearchParams(window.location.search);
        const symbol = urlParams.get('symbol') || 'BTCUSDT';
        const initialTimeframe = urlParams.get('timeframe') || '1h';
        
        // Chart instance
        let chart = null;
        let candlestickSeries = null;
        let volumeSeries = null;
        let currentTimeframe = initialTimeframe;
        let isChartReady = false;
        
        // Store latest data for indicator updates
        let latestData = {
            rsi: null,
            mfi: null,
            signal: null,
            candles: []
        };
        
        // API endpoint (your bot's server)
        const API_BASE = window.location.origin;
        
        // Indicator thresholds (Matching Pine Script: rsi_lower=20, rsi_upper=80)
        const RSI_OVERSOLD = 20;
        const RSI_OVERBOUGHT = 80;
        const MFI_OVERSOLD = 20;
        const MFI_OVERBOUGHT = 80;
        
        // ============================================================
        // PRICE FORMATTING HELPERS (Phase 1: Professional Formatting)
        // ============================================================
        
        /**
         * Detect optimal precision based on price value (Phase 6: Refined)
         * @param {number} price - Price value
         * @returns {number} Precision (2-8 decimal places)
         */
        function detectPrecision(price) {
            if (!price || price === 0) return 2;
            
            const absPrice = Math.abs(price);
            
            // Phase 6: Refined precision logic
            if (absPrice >= 1000) return 2;      // BTC: $43,250.50
            if (absPrice >= 100) return 3;       // ETH: $3,526.440
            if (absPrice >= 10) return 4;        // BNB: $654.3210
            if (absPrice >= 1) return 5;         // ADA: $1.23450
            if (absPrice >= 0.1) return 6;       // DOGE: $0.123456
            if (absPrice >= 0.001) return 7;     // Small: $0.0123456
            return 8;                             // SHIB: $0.00001234
        }
        
        /**
         * Get user's locale (defaults to en-US)
         */
        function getUserLocale() {
            return window.navigator.languages?.[0] || 'en-US';
        }
        
        /**
         * Create price formatter with auto-precision
         */
        function createPriceFormatter(price) {
            const precision = detectPrecision(price);
            return new Intl.NumberFormat(getUserLocale(), {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: precision,
                maximumFractionDigits: precision
            });
        }
        
        /**
         * Format price with proper precision
         * @param {number} price - Price value
         * @returns {string} Formatted price like "$43,250.50"
         */
        function formatPrice(price) {
            if (!price || isNaN(price)) return '$0.00';
            
            try {
                const formatter = createPriceFormatter(price);
                return formatter.format(price);
            } catch (error) {
                console.error('Error formatting price:', error);
                return `$${price.toFixed(2)}`;
            }
        }
        
        /**
         * Format percentage with sign
         * @param {number} value - Percentage value (e.g., 0.0234 for 2.34%)
         * @returns {string} Formatted like "+2.34%" or "-1.56%"
         */
        function formatPercentage(value) {
            if (value === 0 || isNaN(value)) return '0.00%';
            
            try {
                const percentFormatter = new Intl.NumberFormat(getUserLocale(), {
                    style: 'percent',
                    signDisplay: 'always',  // Always show +/-
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
                return percentFormatter.format(value);
            } catch (error) {
                console.error('Error formatting percentage:', error);
                const sign = value >= 0 ? '+' : '';
                return `${sign}${(value * 100).toFixed(2)}%`;
            }
        }
        
        /**
         * Format volume with compact notation (K/M/B)
         * @param {number} volume - Volume value
         * @returns {string} Formatted like "1.23K" or "45.68M"
         */
        function formatVolume(volume) {
            if (!volume || volume === 0) return '0';
            
            try {
                const volumeFormatter = new Intl.NumberFormat(getUserLocale(), {
                    notation: 'compact',
                    compactDisplay: 'short',
                    maximumFractionDigits: 2
                });
                return volumeFormatter.format(volume);
            } catch (error) {
                console.error('Error formatting volume:', error);
                // Fallback to manual K/M/B
                if (volume >= 1e9) return (volume / 1e9).toFixed(2) + 'B';
                if (volume >= 1e6) return (volume / 1e6).toFixed(2) + 'M';
                if (volume >= 1e3) return (volume / 1e3).toFixed(2) + 'K';
                return volume.toFixed(0);
            }
        }
        
        // ============================================================
        // OHLCV LEGEND HELPERS (Phase 2: OHLCV Display)
        // ============================================================
        
        /**
         * Update OHLCV legend with bar data
         * @param {object} bar - Bar data {open, high, low, close}
         */
        function updateOHLCVLegend(bar) {
            if (!bar) return;
            
            const legend = document.getElementById('ohlcv-legend');
            const symbolEl = document.getElementById('legend-symbol');
            const openEl = document.getElementById('legend-open');
            const highEl = document.getElementById('legend-high');
            const lowEl = document.getElementById('legend-low');
            const closeEl = document.getElementById('legend-close');
            const changeEl = document.getElementById('legend-change');
            
            if (!legend || !symbolEl || !openEl || !highEl || !lowEl || !closeEl || !changeEl) {
                console.error('OHLCV legend elements not found');
                return;
            }
            
            // Show legend
            legend.style.display = 'block';
            
            // Update symbol
            symbolEl.textContent = symbol;
            
            // Update OHLCV values with auto-precision
            openEl.textContent = formatPrice(bar.open);
            highEl.textContent = formatPrice(bar.high);
            lowEl.textContent = formatPrice(bar.low);
            closeEl.textContent = formatPrice(bar.close);
            
            // Calculate and display change
            const change = bar.close - bar.open;
            const changePercent = (change / bar.open) * 100;
            const changeText = `${change >= 0 ? '+' : ''}${formatPrice(Math.abs(change))} (${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(2)}%)`;
            
            changeEl.textContent = changeText;
            changeEl.className = change >= 0 ? 'legend-change positive' : 'legend-change negative';
            
            // Color-code close value
            closeEl.className = change >= 0 ? 'legend-value positive' : 'legend-value negative';
        }
        
        /**
         * Hide OHLCV legend when crosshair leaves
         */
        function hideOHLCVLegend() {
            const legend = document.getElementById('ohlcv-legend');
            if (legend) {
                // Keep legend visible with latest data instead of hiding completely
                // legend.style.display = 'none';
            }
        }
        
        // ============================================================
        // HAPTIC FEEDBACK
        // ============================================================
        
        // Haptic feedback helper (Best practice from docs)
        function hapticFeedback(type = 'light') {
            if (tg.HapticFeedback) {
                switch(type) {
                    case 'light':
                        tg.HapticFeedback.impactOccurred('light');
                        break;
                    case 'medium':
                        tg.HapticFeedback.impactOccurred('medium');
                        break;
                    case 'heavy':
                        tg.HapticFeedback.impactOccurred('heavy');
                        break;
                    case 'success':
                        tg.HapticFeedback.notificationOccurred('success');
                        break;
                    case 'error':
                        tg.HapticFeedback.notificationOccurred('error');
                        break;
                    case 'warning':
                        tg.HapticFeedback.notificationOccurred('warning');
                        break;
                }
            }
        }
        
        // Get theme colors from Telegram
        function getThemeColors() {
            const theme = tg.themeParams;
            return {
                background: theme.bg_color || '#1a1a1a',
                textColor: theme.text_color || '#d1d4dc',
                gridColor: theme.hint_color || '#2a2a2a',
                upColor: '#26a69a',
                downColor: '#ef5350',
            };
        }
        
        // Initialize chart
        function initChart() {
            try {
                console.log('üìä Initializing chart...');
                const container = document.getElementById('chartContainer');
                
                if (!container) {
                    throw new Error('Chart container not found');
                }
                
                console.log('Container dimensions:', container.clientWidth, 'x', container.clientHeight);
                
                const colors = getThemeColors();
                console.log('Theme colors:', colors);
                
                console.log('Creating chart...');
                chart = LightweightCharts.createChart(container, {
                    width: container.clientWidth,
                    height: container.clientHeight,
                    layout: {
                        background: { 
                            type: 'solid',
                            color: '#131722'  // TradingView professional BG
                        },
                        textColor: '#D1D4DC',  // TradingView text
                        fontSize: 12,
                        fontFamily: '-apple-system, BlinkMacSystemFont, "SF Pro Display", "Trebuchet MS", Roboto, Ubuntu, sans-serif',
                    },
                    grid: {
                        vertLines: { 
                            color: '#363C4E',  // TradingView grid
                            style: 0,  // Solid
                            visible: true,
                        },
                        horzLines: { 
                            color: '#363C4E',
                            style: 0,
                            visible: true,
                        },
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                        vertLine: {
                            color: '#758696',  // TradingView professional crosshair
                            width: 1,
                            style: LightweightCharts.LineStyle.Dashed,  // Dashed line (Phase 4)
                            labelBackgroundColor: '#2962FF',  // TradingView blue
                            labelVisible: true,
                        },
                        horzLine: {
                            color: '#758696',  // TradingView professional crosshair
                            width: 1,
                            style: LightweightCharts.LineStyle.Dashed,  // Dashed line (Phase 4)
                            labelBackgroundColor: '#2962FF',  // TradingView blue
                            labelVisible: true,
                        },
                    },
                    rightPriceScale: {
                        borderColor: '#2A2E39',  // TradingView border
                        textColor: '#D1D4DC',
                    },
                    timeScale: {
                        borderColor: '#2A2E39',
                        textColor: '#D1D4DC',
                        timeVisible: true,
                        secondsVisible: false,
                        rightOffset: 5,
                        barSpacing: 10,
                        fixLeftEdge: false,
                        fixRightEdge: false,
                    },
                    localization: {
                        // Apply professional price formatter
                        priceFormatter: (price) => formatPrice(price),
                    },
                    handleScroll: {
                        mouseWheel: true,
                        pressedMouseMove: true,
                        horzTouchDrag: true,  // Enable horizontal touch drag (Phase 5)
                        vertTouchDrag: true,  // Enable vertical touch drag (Phase 5)
                    },
                    handleScale: {
                        axisPressedMouseMove: true,
                        mouseWheel: true,
                        pinch: true,  // Enable pinch zoom for mobile (Phase 5)
                    },
                    kineticScroll: {
                        touch: true,  // Enable kinetic scrolling on mobile (Phase 5)
                        mouse: false,
                    },
                });
            
            console.log('Adding candlestick series...');
            // TradingView professional candlestick colors
            candlestickSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
                upColor: '#26A69A',  // TradingView green (teal)
                downColor: '#EF5350',  // TradingView red
                borderUpColor: '#26A69A',
                borderDownColor: '#EF5350',
                wickUpColor: '#26A69A',
                wickDownColor: '#EF5350',
                borderVisible: false,
                priceFormat: {
                    type: 'price',
                    precision: 2,
                    minMove: 0.01,
                },
            });
            console.log('Candlestick series added');
            
            console.log('Adding volume series...');
            volumeSeries = chart.addSeries(LightweightCharts.HistogramSeries, {
                color: '#26A69A',  // Match up candle color
                priceFormat: {
                    type: 'volume',
                },
                priceScaleId: '',
            });
            console.log('Volume series added');
            
            // Apply K/M/B formatting to volume axis (Phase 3)
            volumeSeries.priceScale().applyOptions({
                scaleMargins: {
                    top: 0.8,
                    bottom: 0,
                },
            });
            
            // Override volume formatter with K/M/B notation
            volumeSeries.applyOptions({
                priceFormat: {
                    type: 'custom',
                    formatter: (volume) => formatVolume(volume),
                },
            });
            
            console.log('‚úÖ Chart initialized successfully');
            isChartReady = true;
            
            // Subscribe to crosshair move for interactive indicators (Best practice from docs)
            chart.subscribeCrosshairMove((param) => {
                if (param.time) {
                    const data = param.seriesData.get(candlestickSeries);
                    if (data) {
                        // Update price display with crosshair data
                        updatePrice(data.close, data.close - data.open);
                        
                        // Update OHLCV legend (Phase 2)
                        updateOHLCVLegend(data);
                    }
                } else {
                    // Reset to latest when crosshair leaves
                    if (latestData.rsi !== null) {
                        updateIndicatorDisplay(latestData.rsi, latestData.mfi);
                    }
                    
                    // Hide OHLCV legend (Phase 2)
                    hideOHLCVLegend();
                }
            });
            
            // Subscribe to visible range changes
            let lastVisibleRange = null;
            chart.timeScale().subscribeVisibleTimeRangeChange((timeRange) => {
                // Debounce haptic feedback (Phase 5)
                if (timeRange && lastVisibleRange) {
                    const diff = Math.abs(
                        (timeRange.to - timeRange.from) - 
                        (lastVisibleRange.to - lastVisibleRange.from)
                    );
                    // Only trigger haptic if zoom changed significantly
                    if (diff > 100) {
                        hapticFeedback('light');  // Light haptic for zoom
                    }
                }
                lastVisibleRange = timeRange;
            });
            
            // Mobile touch gesture enhancements (Phase 5)
            let touchStartTime = 0;
            let touchTimer = null;
            const LONG_PRESS_DURATION = 300; // 300ms for long-press
            
            container.addEventListener('touchstart', (e) => {
                touchStartTime = Date.now();
                
                // Set timer for long-press detection
                touchTimer = setTimeout(() => {
                    // Long-press detected - trigger haptic
                    hapticFeedback('medium');
                    console.log('Long-press detected');
                }, LONG_PRESS_DURATION);
            }, { passive: true });
            
            container.addEventListener('touchend', (e) => {
                const touchDuration = Date.now() - touchStartTime;
                
                // Clear long-press timer
                if (touchTimer) {
                    clearTimeout(touchTimer);
                    touchTimer = null;
                }
                
                // Quick tap - light haptic
                if (touchDuration < LONG_PRESS_DURATION) {
                    hapticFeedback('light');
                }
            }, { passive: true });
            
            container.addEventListener('touchmove', (e) => {
                // Clear long-press timer on move
                if (touchTimer) {
                    clearTimeout(touchTimer);
                    touchTimer = null;
                }
            }, { passive: true });
            
            // Handle resize with debounce (Best practice from docs)
            let resizeTimeout;
            const handleResize = () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (chart && container && isChartReady) {
                        const width = container.clientWidth;
                        const height = container.clientHeight;
                        
                        console.log('Resizing chart to:', width, 'x', height);
                        
                        chart.applyOptions({
                            width: width,
                            height: height,
                        });
                        
                        // Smooth fit content with animation
                        requestAnimationFrame(() => {
                            chart.timeScale().fitContent();
                        });
                    }
                }, 150);
            };
            
            window.addEventListener('resize', handleResize);
            
            // ResizeObserver for more accurate resize detection (Best practice)
            if (typeof ResizeObserver !== 'undefined') {
                const resizeObserver = new ResizeObserver(entries => {
                    if (entries.length === 0) return;
                    handleResize();
                });
                resizeObserver.observe(container);
            }
            
            // Optimized touch handling (Best practice from mobile docs)
            let touchStartDistance = 0;
            
            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    // Calculate initial pinch distance
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                    e.preventDefault();
                } else if (e.touches.length === 1) {
                    // Single touch - allow panning
                    hapticFeedback('light');
                }
            }, { passive: false });
            
            container.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    // Pinch zoom in progress
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Trigger haptic feedback if pinch is significant
                    if (Math.abs(distance - touchStartDistance) > 50) {
                        hapticFeedback('light');
                        touchStartDistance = distance;
                    }
                    
                    e.preventDefault();
                }
                e.stopPropagation();
            }, { passive: false });
            
            // Long press for context menu (Best practice)
            let longPressTimer;
            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    longPressTimer = setTimeout(() => {
                        hapticFeedback('medium');
                        // Could show custom context menu here
                        console.log('Long press detected');
                    }, 500);
                }
            });
            
            container.addEventListener('touchend', () => {
                clearTimeout(longPressTimer);
            });
            
            container.addEventListener('touchmove', () => {
                clearTimeout(longPressTimer);
            });
            
            } catch (error) {
                console.error('‚ùå Error initializing chart:', error);
                console.error('Error stack:', error.stack);
                document.getElementById('loading').innerHTML = `
                    <div style="color: red; padding: 20px; text-align: center;">
                        <h3>‚ö†Ô∏è Chart Initialization Failed</h3>
                        <p>${error.message}</p>
                        <button onclick="location.reload()">Reload</button>
                    </div>
                `;
                throw error;
            }
        }
        
        // Load chart data
        async function loadChartData(tf) {
            try {
                showLoading();
                
                console.log(`Fetching data: ${API_BASE}/api/chart?symbol=${symbol}&timeframe=${tf}`);
                
                // Fetch data from your backend
                const response = await fetch(`${API_BASE}/api/chart?symbol=${symbol}&timeframe=${tf}`);
                
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Error response:', errorText);
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();
                console.log('Received data:', data);
                console.log('Number of candles:', data.candles?.length);
                
                // Validate data
                if (!data.candles || data.candles.length === 0) {
                    throw new Error('No candle data received');
                }
                
                // Check timestamp format
                const firstTime = data.candles[0].time;
                console.log('First timestamp:', firstTime, typeof firstTime);
                
                // Validate timestamp is in seconds (not milliseconds)
                // Unix timestamp in seconds should be around 1.7 billion (year 2024)
                // Unix timestamp in milliseconds would be 1700+ billion
                if (firstTime > 10000000000) {
                    console.warn('Timestamp appears to be in milliseconds, converting to seconds');
                    // Convert all timestamps to seconds
                    data.candles.forEach(c => {
                        c.time = Math.floor(c.time / 1000);
                    });
                }
                
                // Haptic feedback on success
                hapticFeedback('success');
                
                // Update header
                document.getElementById('symbol').textContent = symbol;
                updatePrice(data.currentPrice, data.priceChange);
                
                // Store latest data
                latestData.rsi = data.rsi;
                latestData.mfi = data.mfi;
                
                // Update indicators with dynamic display
                updateIndicatorDisplay(data.rsi, data.mfi);
                
                // Update signal badge
                updateSignalBadge(data.rsi, data.mfi);
                
                // Update chart with data validation (Best practice from docs)
                // LightweightCharts REQUIRES sorted data by time (ascending)
                const sortedCandles = data.candles.sort((a, b) => a.time - b.time);
                
                // Remove duplicates (Best practice)
                const uniqueCandles = [];
                const seenTimes = new Set();
                for (const candle of sortedCandles) {
                    if (!seenTimes.has(candle.time)) {
                        uniqueCandles.push(candle);
                        seenTimes.add(candle.time);
                    }
                }
                
                console.log('Original candles:', sortedCandles.length);
                console.log('Unique candles:', uniqueCandles.length);
                
                // Validate OHLC data (Best practice)
                const candleData = uniqueCandles.map(c => {
                    const open = parseFloat(c.open);
                    const high = parseFloat(c.high);
                    const low = parseFloat(c.low);
                    const close = parseFloat(c.close);
                    
                    // Ensure high is highest and low is lowest
                    const validHigh = Math.max(open, high, low, close);
                    const validLow = Math.min(open, high, low, close);
                    
                    return {
                        time: c.time,  // Unix timestamp in seconds
                        open: open,
                        high: validHigh,
                        low: validLow,
                        close: close,
                    };
                });
                
                console.log('First candle:', candleData[0]);
                console.log('Last candle:', candleData[candleData.length - 1]);
                console.log('Data sorted, validated and formatted');
                
                const volumeData = uniqueCandles.map(c => ({
                    time: c.time,
                    value: parseFloat(c.volume),
                    color: c.close >= c.open ? '#26a69a80' : '#ef535080',
                }));
                
                console.log('Setting candlestick data...');
                // Use setData for initial load, update() for real-time (Best practice)
                candlestickSeries.setData(candleData);
                console.log('Candlestick data set successfully');
                
                console.log('Setting volume data...');
                volumeSeries.setData(volumeData);
                console.log('Volume data set successfully');
                
                console.log('Fitting content...');
                // Smooth animation for fit (Best practice)
                requestAnimationFrame(() => {
                    if (chart && isChartReady) {
                        chart.timeScale().fitContent();
                        console.log('Fit content completed');
                    }
                });
                
                console.log('‚úÖ Chart updated successfully');
                
                // Smooth fade out loading
                setTimeout(() => {
                    hideLoading();
                }, 100);
                
            } catch (error) {
                hideLoading();
                console.error('Error loading chart data:', error);
                console.error('Error stack:', error.stack);
                
                // Haptic feedback on error
                hapticFeedback('error');
                
                // Show error to user
                if (tg.showAlert) {
                    tg.showAlert(`Error: ${error.message}`);
                } else {
                    showError(`Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu: ${error.message}`);
                }
            }
        }
        
        function updatePrice(price, change) {
            const priceEl = document.getElementById('price');
            // Use new formatPrice function with auto-precision
            priceEl.textContent = formatPrice(price);
            priceEl.className = change >= 0 ? 'price-up' : 'price-down';
        }
        
        // Update indicator display with dynamic colors and zones (Best practice)
        function updateIndicatorDisplay(rsi, mfi) {
            // RSI
            const rsiEl = document.getElementById('rsi-value');
            const rsiDot = document.getElementById('rsi-dot');
            
            rsiEl.textContent = rsi.toFixed(2);
            
            if (rsi < RSI_OVERSOLD) {
                rsiEl.className = 'indicator-value rsi-oversold';
                rsiDot.style.background = '#26A69A';
            } else if (rsi > RSI_OVERBOUGHT) {
                rsiEl.className = 'indicator-value rsi-overbought';
                rsiDot.style.background = '#EF5350';
            } else {
                rsiEl.className = 'indicator-value rsi-neutral';
                rsiDot.style.background = '#2962FF';
            }
            
            // MFI
            const mfiEl = document.getElementById('mfi-value');
            const mfiDot = document.getElementById('mfi-dot');
            
            mfiEl.textContent = mfi.toFixed(2);
            
            if (mfi < MFI_OVERSOLD) {
                mfiEl.className = 'indicator-value mfi-oversold';
                mfiDot.style.background = '#26A69A';
            } else if (mfi > MFI_OVERBOUGHT) {
                mfiEl.className = 'indicator-value mfi-overbought';
                mfiDot.style.background = '#EF5350';
            } else {
                mfiEl.className = 'indicator-value mfi-neutral';
                mfiDot.style.background = '#FF6D00';
            }
        }
        
        // Update signal badge based on RSI/MFI consensus (Best practice)
        function updateSignalBadge(rsi, mfi) {
            const signalBadge = document.getElementById('signal-badge');
            const signalText = document.getElementById('signal-text');
            
            // Determine signals
            let rsiSignal = 0;
            if (rsi < RSI_OVERSOLD) rsiSignal = 1;  // BUY
            else if (rsi > RSI_OVERBOUGHT) rsiSignal = -1;  // SELL
            
            let mfiSignal = 0;
            if (mfi < MFI_OVERSOLD) mfiSignal = 1;  // BUY
            else if (mfi > MFI_OVERBOUGHT) mfiSignal = -1;  // SELL
            
            // Consensus (both must agree)
            let finalSignal = 'NEUTRAL';
            let signalClass = 'signal-neutral';
            let arrow = '‚îÅ';
            
            if (rsiSignal === 1 && mfiSignal === 1) {
                finalSignal = 'BUY';
                signalClass = 'signal-buy';
                arrow = '‚Üë';
            } else if (rsiSignal === -1 && mfiSignal === -1) {
                finalSignal = 'SELL';
                signalClass = 'signal-sell';
                arrow = '‚Üì';
            }
            
            // Update badge
            signalBadge.className = `signal-badge ${signalClass}`;
            signalBadge.textContent = `${arrow} ${finalSignal}`;
            signalBadge.style.display = 'block';
            
            // Update signal text in indicators panel
            signalText.textContent = `${arrow} ${finalSignal}`;
            signalText.className = `indicator-value ${signalClass.replace('signal-', '')}`;
            
            // Store signal
            latestData.signal = finalSignal;
            
            // Haptic feedback on signal change
            if (finalSignal !== 'NEUTRAL') {
                hapticFeedback('success');
            }
        }
        
        function showLoading() {
            const loadingEl = document.getElementById('loading');
            loadingEl.classList.remove('hidden');
            loadingEl.style.display = 'block';
        }
        
        function hideLoading() {
            const loadingEl = document.getElementById('loading');
            loadingEl.classList.add('hidden');
            setTimeout(() => {
                loadingEl.style.display = 'none';
            }, 300);
        }
        
        function showError(message) {
            const errorEl = document.getElementById('error');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            setTimeout(() => {
                errorEl.style.display = 'none';
            }, 3000);
        }
        
        // Timeframe buttons
        document.querySelectorAll('.tf-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                try {
                    console.log('Timeframe button clicked:', btn.dataset.tf);
                    
                    // Haptic feedback
                    hapticFeedback('light');
                    
                    document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    currentTimeframe = btn.dataset.tf;
                    console.log('Loading data for timeframe:', currentTimeframe);
                    loadChartData(currentTimeframe);
                } catch (error) {
                    console.error('Error in timeframe button click:', error);
                }
            });
        });
        
        // Double-tap to reset zoom (Best practice from mobile examples)
        let lastTapTime = 0;
        let tapTimeout;
        document.getElementById('chartContainer').addEventListener('touchend', (e) => {
            const currentTime = Date.now();
            const tapGap = currentTime - lastTapTime;
            
            clearTimeout(tapTimeout);
            
            if (tapGap < 300 && tapGap > 0) {
                // Double tap detected
                console.log('Double tap - resetting zoom');
                if (chart && isChartReady) {
                    // Smooth animation
                    requestAnimationFrame(() => {
                        chart.timeScale().fitContent();
                    });
                    hapticFeedback('medium');
                }
                lastTapTime = 0; // Reset to prevent triple-tap
            } else {
                // Single tap - set timer
                tapTimeout = setTimeout(() => {
                    lastTapTime = 0;
                }, 300);
                lastTapTime = currentTime;
            }
        });
        
        // Theme change listener
        if (tg.onEvent) {
            tg.onEvent('themeChanged', () => {
                if (chart) {
                    const colors = getThemeColors();
                    chart.applyOptions({
                        layout: {
                            background: { 
                                type: 'solid',
                                color: colors.background 
                            },
                            textColor: colors.textColor,
                        },
                        grid: {
                            vertLines: { color: colors.gridColor },
                            horzLines: { color: colors.gridColor },
                        }
                    });
                }
            });
        }
        
        // Viewport change listener
        if (tg.onEvent) {
            tg.onEvent('viewportChanged', (data) => {
                console.log('Viewport changed:', data);
                if (chart) {
                    const container = document.getElementById('chartContainer');
                    chart.applyOptions({
                        width: container.clientWidth,
                        height: container.clientHeight,
                    });
                    // Only fit content when viewport is stable
                    if (data && data.isStateStable) {
                        chart.timeScale().fitContent();
                    }
                }
            });
            
            // Safe area change listeners (Bot API 8.0+)
            if (tg.isVersionAtLeast('8.0')) {
                tg.onEvent('safeAreaChanged', () => {
                    console.log('Safe area changed');
                    if (tg.safeAreaInset) {
                        const { top, bottom, left, right } = tg.safeAreaInset;
                        document.documentElement.style.setProperty('--tg-safe-area-inset-top', `${top}px`);
                        document.documentElement.style.setProperty('--tg-safe-area-inset-bottom', `${bottom}px`);
                        document.documentElement.style.setProperty('--tg-safe-area-inset-left', `${left}px`);
                        document.documentElement.style.setProperty('--tg-safe-area-inset-right', `${right}px`);
                    }
                });
                
                tg.onEvent('contentSafeAreaChanged', () => {
                    console.log('Content safe area changed');
                    if (tg.contentSafeAreaInset) {
                        const { top, bottom } = tg.contentSafeAreaInset;
                        document.documentElement.style.setProperty('--tg-content-safe-area-inset-top', `${top}px`);
                        document.documentElement.style.setProperty('--tg-content-safe-area-inset-bottom', `${bottom}px`);
                    }
                });
            }
        }
        
        // Apply safe area insets if available (Best practice from docs)
        if (tg.isVersionAtLeast('8.0')) {
            // Use safeAreaInset for system UI (notches, navigation bars)
            if (tg.safeAreaInset) {
                const { top, bottom, left, right } = tg.safeAreaInset;
                console.log('Safe area insets:', { top, bottom, left, right });
                document.documentElement.style.setProperty('--tg-safe-area-inset-top', `${top}px`);
                document.documentElement.style.setProperty('--tg-safe-area-inset-bottom', `${bottom}px`);
                document.documentElement.style.setProperty('--tg-safe-area-inset-left', `${left}px`);
                document.documentElement.style.setProperty('--tg-safe-area-inset-right', `${right}px`);
            }
            
            // Use contentSafeAreaInset for Telegram UI elements
            if (tg.contentSafeAreaInset) {
                const { top, bottom, left, right } = tg.contentSafeAreaInset;
                console.log('Content safe area insets:', { top, bottom, left, right });
                document.documentElement.style.setProperty('--tg-content-safe-area-inset-top', `${top}px`);
                document.documentElement.style.setProperty('--tg-content-safe-area-inset-bottom', `${bottom}px`);
            }
        }
        
        // Real-time update using series.update() (Best practice from docs)
        let lastUpdateData = null;
        
        async function updateRealtimeData() {
            if (!isChartReady || !candlestickSeries) return;
            
            try {
                const response = await fetch(`${API_BASE}/api/chart?symbol=${symbol}&timeframe=${currentTimeframe}`);
                if (!response.ok) return;
                
                const data = await response.json();
                if (!data.candles || data.candles.length === 0) return;
                
                // Get last candle
                const lastCandle = data.candles[data.candles.length - 1];
                
                // Validate timestamp
                let time = lastCandle.time;
                if (time > 10000000000) {
                    time = Math.floor(time / 1000);
                }
                
                // Validate OHLC
                const open = parseFloat(lastCandle.open);
                const high = parseFloat(lastCandle.high);
                const low = parseFloat(lastCandle.low);
                const close = parseFloat(lastCandle.close);
                const validHigh = Math.max(open, high, low, close);
                const validLow = Math.min(open, high, low, close);
                
                const newData = {
                    time: time,
                    open: open,
                    high: validHigh,
                    low: validLow,
                    close: close,
                };
                
                // Use update() for real-time, not setData() (Best practice)
                candlestickSeries.update(newData);
                
                // Update volume
                volumeSeries.update({
                    time: time,
                    value: parseFloat(lastCandle.volume),
                    color: close >= open ? '#26a69a80' : '#ef535080',
                });
                
                // Update price display
                updatePrice(data.currentPrice, data.priceChange);
                
                // Update OHLCV legend with latest data (Phase 2)
                updateOHLCVLegend(newData);
                
                // Update indicators with dynamic display
                updateIndicatorDisplay(data.rsi, data.mfi);
                
                // Update signal badge
                updateSignalBadge(data.rsi, data.mfi);
                
                console.log('Real-time update completed');
                
            } catch (error) {
                console.error('Real-time update error:', error);
            }
        }
        
        // Initialize with error handling
        try {
            console.log('=== Starting chart initialization ===');
            initChart();
            console.log('=== Starting data load ===');
            loadChartData(currentTimeframe);
            
            // Real-time updates using requestAnimationFrame (Best practice from TradingView)
            // Update every 15 seconds (optimal balance between freshness and performance)
            let updateIntervalId = null;
            let lastUpdateTime = 0;
            const UPDATE_INTERVAL = 15000; // 15 seconds
            
            function scheduleUpdate() {
                const now = Date.now();
                if (now - lastUpdateTime >= UPDATE_INTERVAL) {
                    lastUpdateTime = now;
                    updateRealtimeData();
                }
                updateIntervalId = requestAnimationFrame(scheduleUpdate);
            }
            
            // Start update loop
            scheduleUpdate();
            
            // Cleanup on page unload
            window.addEventListener('beforeunload', () => {
                if (updateIntervalId) {
                    cancelAnimationFrame(updateIntervalId);
                }
            });
            
            console.log('=== Initialization complete ===');
        } catch (error) {
            console.error('=== FATAL ERROR ===', error);
            hapticFeedback('error');
            document.getElementById('loading').innerHTML = `
                <div style="color: red; padding: 20px; text-align: center;">
                    <h3>‚ö†Ô∏è Fatal Error</h3>
                    <p>${error.message}</p>
                    <pre style="font-size: 10px; text-align: left; background: #000; padding: 10px; overflow: auto;">${error.stack}</pre>
                    <button onclick="location.reload()" style="margin-top: 10px; padding: 10px 20px; font-size: 16px;">Reload</button>
                </div>
            `;
        }
    </script>
</body>
</html>
