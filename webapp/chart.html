<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <!-- Enhanced mobile viewport with iOS optimization -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
    
    <!-- PWA & Mobile Optimization -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1E222D">
    <meta name="format-detection" content="telephone=no">
    
    <!-- Performance & Rendering -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    
    <title>Live Chart - Crypto Trading Analysis</title>
    
    <!-- Telegram WebApp SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- AI Analysis API Integration -->
    <script src="ai-analysis-api.js"></script>
    
    <!-- History Module -->
    <link rel="stylesheet" href="history.css">
    <script src="history.js"></script>
    
    <!-- Analytics Module -->
    <link rel="stylesheet" href="analytics.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="analytics.js"></script>
    
    <!-- Mobile-First Design System -->
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/ai-tab.css">
    <link rel="stylesheet" href="css/indicators-tab.css">
    
    <!-- Lightweight Charts Library v5.0 with fallback CDN -->
    <script 
        src="https://unpkg.com/lightweight-charts@5.0.0/dist/lightweight-charts.standalone.production.js"
        onerror="loadFallbackChart()"
        id="primary-chart-script">
    </script>
    <script>
        // Fallback CDN for LightweightCharts if unpkg fails
        function loadFallbackChart() {
            console.warn('‚ö†Ô∏è Primary CDN failed, loading fallback...');
            const fallbackScript = document.createElement('script');
            fallbackScript.src = 'https://cdn.jsdelivr.net/npm/lightweight-charts@5.0.0/dist/lightweight-charts.standalone.production.js';
            fallbackScript.onerror = function() {
                console.error('‚ùå All CDNs failed to load LightweightCharts');
                showError('Unable to load chart library. Please check your internet connection.');
            };
            document.head.appendChild(fallbackScript);
        }
    </script>
    
    <style>
        /* ============================================================
           MOBILE-FIRST DESIGN WITH iOS/ANDROID OPTIMIZATION
           Note: CSS variables are defined in css/variables.css
           ============================================================ */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* Improve tap performance on mobile */
            -webkit-tap-highlight-color: transparent;
            /* Prevent text selection on touch */
            -webkit-touch-callout: none;
        }
        
        html {
            /* Smooth scrolling for better UX */
            scroll-behavior: smooth;
            /* Prevent horizontal scroll */
            overflow-x: hidden;
            /* iOS momentum scrolling */
            -webkit-overflow-scrolling: touch;
        }
        
        body {
            font-family: var(--font-family);
            background: var(--primary-bg);
            color: var(--text-primary);
            overflow: hidden;
            /* iOS safe area padding */
            padding-top: var(--safe-area-inset-top);
            padding-right: var(--safe-area-inset-right);
            padding-bottom: var(--safe-area-inset-bottom);
            padding-left: var(--safe-area-inset-left);
            /* Prevent bounce effect on iOS */
            position: fixed;
            width: 100%;
            height: 100%;
            /* Optimize font rendering */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: var(--z-toast);
            transition: opacity var(--transition-normal), visibility var(--transition-normal);
        }
        
        #loading.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        .spinner {
            border: 4px solid var(--chart-grid-color);
            border-top: 4px solid var(--accent-blue);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #header {
            background: var(--secondary-bg);
            padding: var(--space-sm) var(--space-md);
            display: flex;
            flex-direction: column;
            gap: 6px;
            border-bottom: 1px solid var(--border-color);
            min-height: 60px;
        }
        
        #symbol-switcher {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            flex-wrap: wrap;
        }
        
        #symbol-select {
            flex: 1;
            min-width: 150px;
            background: var(--primary-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: 6px 10px;
            font-size: var(--font-sm);
            font-weight: var(--weight-semibold);
            cursor: pointer;
            outline: none;
            transition: all var(--transition-fast);
        }
        
        #symbol-select:hover {
            background: var(--secondary-bg);
            border-color: var(--accent-blue);
        }
        
        #symbol-select:focus {
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 2px rgba(41, 98, 255, 0.2);
        }
        
        #custom-symbol-input {
            flex: 1;
            min-width: 150px;
            background: var(--primary-bg);
            color: var(--text-primary);
            border: 1px solid var(--accent-blue);
            border-radius: var(--radius-md);
            padding: 6px 10px;
            font-size: var(--font-sm);
            font-weight: var(--weight-semibold);
            outline: none;
            text-transform: uppercase;
            display: none;
        }
        
        #custom-symbol-input:focus {
            background: var(--secondary-bg);
            box-shadow: 0 0 0 2px rgba(41, 98, 255, 0.2);
        }
        
        #custom-symbol-input::placeholder {
            color: var(--text-secondary);
            text-transform: none;
        }
        
        .symbol-btn {
            background: var(--accent-blue);
            color: white;
            border: none;
            border-radius: var(--radius-md);
            padding: 6px 14px;
            font-size: var(--font-xs);
            font-weight: var(--weight-semibold);
            cursor: pointer;
            transition: all var(--transition-fast);
            display: none;
        }
        
        .symbol-btn:hover {
            background: #1E88E5;
            transform: translateY(-1px);
        }
        
        .symbol-btn:active {
            transform: translateY(0);
        }
        
        #symbol {
            font-size: var(--font-xs);
            font-weight: var(--weight-medium);
            color: var(--text-secondary);
            letter-spacing: 0.02em;
        }
        
        #price {
            font-size: var(--font-lg);
            font-weight: var(--weight-semibold);
            font-variant-numeric: tabular-nums;  /* Monospace numbers */
        }
        
        .price-up { color: var(--accent-green); }
        .price-down { color: var(--accent-red); }
        
        /* HIDE OLD TAB SYSTEM - Using components.css .bottom-nav instead */
        #tabs {
            display: none !important;
        }
        
        .tab-btn {
            display: none !important;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* OLD TIMEFRAME BAR - HIDDEN (using mobile TimeframeSwitcher instead) */
        #timeframes {
            display: none !important;
        }
        
        /* NEW MOBILE TIMEFRAME CONTAINER */
        #timeframe-container {
            padding: var(--space-sm);
            padding-top: 4px;
            padding-bottom: 4px;
            background: var(--secondary-bg);
            border-bottom: 1px solid var(--border-color);
        }
        
        /* TAB CONTENT WRAPPERS */
        [data-tab-content] {
            min-height: calc(100vh - 165px - 20px);
            padding-bottom: 0; /* Bottom nav is fixed, no padding needed */
        }
        
        [data-tab-content="chart"] {
            padding-bottom: 0;
            min-height: 0; /* Chart has its own height calculation */
            overflow: visible; /* Ensure no clipping of touch events */
            position: relative;
        }
        
        #timeframes::-webkit-scrollbar {
            height: 4px;
        }
        
        #timeframes::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        #timeframes::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 2px;
        }
        
        .tf-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #333;
            color: #aaa;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .tf-btn:active {
            transform: scale(0.95);
        }
        
        .tf-btn.active {
            background: #2196F3;
            color: #fff;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.4);
        }
        
        .tf-btn:hover:not(.active) {
            background: #404040;
            color: #fff;
        }
        
        #chartContainer {
            width: 100%;
            /* Chart height minus header, timeframe, and bottom nav space */
            height: calc(100vh - 165px - 20px - var(--safe-area-inset-top) - var(--safe-area-inset-bottom));
            position: relative;
            margin: 0;
            padding: 0;
            /* Optimized touch handling for mobile - allow all gestures */
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            /* GPU acceleration for smoother scrolling */
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            will-change: transform;
            /* Better rendering on mobile */
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            /* Ensure touch events are captured */
            pointer-events: auto;
        }
        
        /* Mobile-specific chart optimizations */
        @media (max-width: 768px) {
            #chartContainer {
                /* Full viewport height minus header and timeframe */
                height: calc(100vh - 165px - 20px - var(--safe-area-inset-top) - var(--safe-area-inset-bottom));
                /* Disable text selection on mobile */
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }
            
            /* Larger touch targets for mobile */
            .tool-btn {
                min-height: 44px; /* iOS recommended touch target */
                padding: 10px 18px;
            }
            
            .tf-btn {
                min-height: 44px;
                padding: 10px 18px;
            }
        }
        
        /* iOS notch support */
        @supports (padding: max(0px)) {
            #header {
                padding-top: max(8px, var(--safe-area-inset-top));
                padding-left: max(16px, var(--safe-area-inset-left));
                padding-right: max(16px, var(--safe-area-inset-right));
            }
        }
        
        #indicators {
            display: none;  /* Hidden by default */
            padding: 20px;
            background: #1a1a1a;
            height: calc(100vh - 165px - 20px);
            overflow-y: auto;
        }
        
        #indicators.active {
            display: block;
        }
        
        #ai-analysis {
            display: none;  /* Hidden by default */
            padding: 20px;
            background: #1a1a1a;
            height: calc(100vh - 165px - 20px);
            overflow-y: auto;
        }
        
        /* OLD AI STYLES - Now handled by css/ai-tab.css */
        
        .indicator-section {
            background: rgba(37, 37, 37, 0.90);
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
        }
        
        .indicator-title {
            font-size: 16px;
            font-weight: 600;
            color: #D1D4DC;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .indicator-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            gap: 12px;
            font-size: 15px;
        }
        
        .indicator-label {
            color: #bbb;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 15px;
        }
        
        .indicator-value {
            font-weight: 700;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        /* RSI Colors based on zones */
        .rsi-oversold { color: var(--accent-green); }
        .rsi-neutral { color: var(--accent-blue); }
        .rsi-overbought { color: var(--accent-red); }
        
        /* MFI Colors based on zones */
        .mfi-oversold { color: var(--accent-green); }
        .mfi-neutral { color: var(--accent-orange); }
        .mfi-overbought { color: var(--accent-red); }
        
        /* Trend arrows */
        .trend-arrow {
            font-size: var(--font-lg);
            display: inline-block;
        }
        
        .trend-up { color: var(--accent-green); }
        .trend-down { color: var(--accent-red); }
        .trend-neutral { color: var(--text-tertiary); opacity: 0.5; }
        
        /* Optional subtle animation for important signals only */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.85; }
        }
        
        /* Signal badge in indicators panel */
        #indicators .signal-badge {
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-pill);
            font-weight: var(--weight-bold);
            font-size: var(--font-lg);
            backdrop-filter: blur(8px);
            border: 2px solid;
            text-align: center;
            width: 100%;
        }
        
        .signal-buy {
            background: rgba(38, 166, 154, 0.2);
            color: var(--accent-green);
            border-color: var(--accent-green);
        }
        
        .signal-sell {
            background: rgba(239, 83, 80, 0.2);
            color: var(--accent-red);
            border-color: var(--accent-red);
        }
        
        .signal-neutral {
            background: rgba(119, 119, 119, 0.2);
            color: var(--text-secondary);
            border-color: var(--text-tertiary);
        }
        
        /* ============================================================
           OHLCV LEGEND (Phase 2: TradingView-style legend)
           ============================================================ */
        #ohlcv-legend {
            display: none;  /* Hidden - info already in header */
            position: absolute;
            left: 10px;
            top: 10px;
            z-index: 5;
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }
        
        #ohlcv-legend.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        .legend-symbol {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 4px;
            letter-spacing: -0.02em;
            color: #D1D4DC;
        }
        
        .legend-ohlcv {
            font-size: 11px;
            font-variant-numeric: tabular-nums;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            line-height: 14px;
        }
        
        .legend-item {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        
        .legend-label {
            color: #787B86;  /* TradingView secondary text */
            font-weight: 500;
        }
        
        .legend-value {
            color: #D1D4DC;  /* TradingView primary text */
            font-weight: 400;
        }
        
        .legend-change {
            font-weight: 600;
            margin-left: 4px;
        }
        
        .legend-change.positive {
            color: #26A69A;  /* TradingView green */
        }
        
        .legend-change.negative {
            color: #EF5350;  /* TradingView red */
        }
        
        /* Mobile compact legend */
        @media (max-width: 567px) {
            #ohlcv-legend {
                left: 8px;  /* Keep on left side on mobile */
                top: 10px;  /* Inside chart container on mobile */
                font-size: 10px;
            }
            
            .legend-symbol {
                font-size: 11px;
                margin-bottom: 3px;
            }
            
            .legend-ohlcv {
                font-size: 10px;
                gap: 6px;
            }
            
            /* AI Analysis mobile optimizations */
            #ai-content {
                font-size: 16px;  /* Slightly smaller than desktop but still readable */
                line-height: 1.75;
            }
            
            .ai-title {
                font-size: 20px;  /* Slightly smaller for mobile */
                font-weight: 700;
            }
            
            .ai-section {
                padding: 18px 14px;  /* Slightly reduced padding on mobile */
                margin-bottom: 18px;
            }
        }
        
        /* Zone indicator dots - No animation */
        .zone-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }
        
        /* Disable animations on low-end devices (TradingView best practice) */
        @media (prefers-reduced-motion: reduce) {
            .trend-arrow,
            .signal-badge,
            .zone-dot,
            #indicators {
                animation: none !important;
            }
        }
        
        #error {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #EF5350;
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            max-width: 80%;
        }
        
        /* Loading spinner */
        .loading-spinner {
            width: 40px;
            height: 40px;
            margin: 0 auto;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #2962FF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div>Loading chart...</div>
    </div>
    
    <div id="error"></div>
    
    <div id="header">
        <div id="symbol-switcher">
            <select id="symbol-select">
                <option value="BTCUSDT">BTC/USDT</option>
                <option value="ETHUSDT">ETH/USDT</option>
                <option value="BNBUSDT">BNB/USDT</option>
                <option value="SOLUSDT">SOL/USDT</option>
                <option value="XRPUSDT">XRP/USDT</option>
                <option value="DOGEUSDT">DOGE/USDT</option>
                <option value="ADAUSDT">ADA/USDT</option>
                <option value="AVAXUSDT">AVAX/USDT</option>
                <option value="DOTUSDT">DOT/USDT</option>
                <option value="MATICUSDT">MATIC/USDT</option>
                <option value="LINKUSDT">LINK/USDT</option>
                <option value="UNIUSDT">UNI/USDT</option>
                <option value="ATOMUSDT">ATOM/USDT</option>
                <option value="LTCUSDT">LTC/USDT</option>
                <option value="ETCUSDT">ETC/USDT</option>
                <option value="CUSTOM">üîç Custom Symbol...</option>
            </select>
            <input 
                type="text" 
                id="custom-symbol-input" 
                placeholder="Nh·∫≠p m√£ coin (VD: PEPE, DOGE, SHIB)" 
                maxlength="20"
            />
            <button id="apply-custom-symbol" class="symbol-btn">‚úì Apply</button>
            <div id="symbol" style="font-size: 10px; color: #787B86;">Loading...</div>
        </div>
        <div style="display: flex; align-items: baseline; gap: 8px; flex-wrap: wrap;">
            <div id="price">--</div>
            <div id="price-change" style="font-size: 12px; font-weight: 500;">--</div>
        </div>
    </div>
    
    <div id="tabs">
        <button class="tab-btn active" data-tab="chart">
            <span style="font-size: 18px;">üìà</span>
            <span>Chart</span>
        </button>
        <button class="tab-btn" data-tab="indicators">
            <span style="font-size: 18px;">üìä</span>
            <span>Indicators</span>
        </button>
        <button class="tab-btn" data-tab="ai">
            <span style="font-size: 18px;">ü§ñ</span>
            <span>AI</span>
        </button>
        <button class="tab-btn" data-tab="history">
            <span style="font-size: 18px;">ÔøΩ</span>
            <span>History</span>
        </button>
    </div>
    
    <!-- Bottom Navigation (Using components.css .bottom-nav) -->
    <nav class="bottom-nav">
        <div class="bottom-nav-container">
            <div class="nav-indicator" id="nav-indicator"></div>
            <button class="nav-item active" data-tab="chart">
                <span class="nav-item-icon">üìà</span>
                <span class="nav-item-label">Chart</span>
            </button>
            <button class="nav-item" data-tab="indicators">
                <span class="nav-item-icon">üìä</span>
                <span class="nav-item-label">Indicators</span>
            </button>
            <button class="nav-item" data-tab="ai">
                <span class="nav-item-icon">ü§ñ</span>
                <span class="nav-item-label">AI</span>
            </button>
            <button class="nav-item" data-tab="history">
                <span class="nav-item-icon">üìã</span>
                <span class="nav-item-label">History</span>
            </button>
        </div>
    </nav>
    
    <!-- Timeframe Switcher Container (New Mobile Component) -->
    <div id="timeframe-container"></div>
    
    <div id="timeframes">
        <button class="tf-btn" data-tf="5m">5M</button>
        <button class="tf-btn active" data-tf="1h">1H</button>
        <button class="tf-btn" data-tf="4h">4H</button>
        <button class="tf-btn" data-tf="1d">1D</button>
    </div>
    
    <!-- OLD Indicators Panel - HIDDEN (using mobile IndicatorPanel instead) -->
    <div id="indicators" style="display: none;">
        <div class="indicator-section">
            <div class="indicator-title">Technical Indicators</div>
            <div class="indicator-row">
                <span class="indicator-label">
                    <span class="zone-dot" id="rsi-dot" style="background: #777;"></span>
                    RSI(6)
                </span>
                <span class="indicator-value" id="rsi-value">--</span>
            </div>
            <div class="indicator-row">
                <span class="indicator-label">
                    <span class="zone-dot" id="mfi-dot" style="background: #777;"></span>
                    MFI(6)
                </span>
                <span class="indicator-value" id="mfi-value">--</span>
            </div>
            <div class="indicator-row">
                <span class="indicator-label">
                    <span class="zone-dot" id="stoch-rsi-dot" style="background: #777;"></span>
                    Stoch RSI
                </span>
                <span class="indicator-value" id="stoch-rsi-value">--</span>
            </div>
            <div class="indicator-row">
                <span class="indicator-label">
                    <span class="zone-dot" id="volume-dot" style="background: #777;"></span>
                    Volume Ratio
                </span>
                <span class="indicator-value" id="volume-value">--</span>
            </div>
        </div>
        
        <div class="indicator-section">
            <div class="indicator-title">Trading Signal</div>
            <div class="indicator-row">
                <span class="indicator-label">Signal:</span>
                <span class="indicator-value" id="signal-text" style="font-size: 16px; color: #aaa;">--</span>
            </div>
            <div id="signal-badge" class="signal-badge signal-neutral" style="display: none; position: relative; top: 0; left: 0; margin-top: 12px;">
                NEUTRAL
            </div>
        </div>
        
        <div class="indicator-section">
            <div class="indicator-title">24h Statistics</div>
            <div class="indicator-row">
                <span class="indicator-label">24h High</span>
                <span class="indicator-value" id="high-24h-value" style="color: #26A69A;">--</span>
            </div>
            <div class="indicator-row">
                <span class="indicator-label">24h Low</span>
                <span class="indicator-value" id="low-24h-value" style="color: #EF5350;">--</span>
            </div>
            <div class="indicator-row">
                <span class="indicator-label">24h Volume</span>
                <span class="indicator-value" id="volume-24h-value">--</span>
            </div>
        </div>
    </div>
    
    <!-- TAB CONTENT SECTIONS FOR MOBILE NAVIGATION -->
    <!-- Chart Tab (default visible) -->
    <div data-tab-content="chart" style="display: block; padding: 0; margin: 0;">
        <div id="chartContainer"></div>
    </div>
    
    <!-- Indicators Tab -->
    <div data-tab-content="indicators" style="display: none; padding: 20px; overflow-y: auto;">
        <div id="indicators-tab-content">
            <!-- Indicators will be dynamically populated by IndicatorsTabController -->
            <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                <div style="font-size: 48px; margin-bottom: 16px;">üìä</div>
                <div style="font-size: 16px;">Loading multi-timeframe indicators...</div>
                <div style="font-size: 13px; margin-top: 8px; color: var(--text-tertiary);">
                    RSI, MFI, Stoch RSI across all timeframes
                </div>
            </div>
        </div>
    </div>
    
    <!-- AI Analysis Tab - Complete Rebuild v2.0 -->
    <div data-tab-content="ai" style="display: none; padding: 0; overflow: hidden; height: calc(100vh - 165px);">
        <div class="ai-content-wrapper" style="
            height: 100%; 
            overflow-y: auto; 
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        ">
            <!-- Main Analyze Button -->
            <button id="ai-analyze-btn">
                <span class="ai-btn-content">
                    <span class="ai-btn-icon">üß†</span>
                    <span class="ai-btn-text">
                        <span class="ai-btn-title">Analyze with Gemini AI</span>
                        <span class="ai-btn-subtitle">BTCUSDT ‚Ä¢ 1h</span>
                    </span>
                </span>
            </button>
            
            <!-- Status Card -->
            <div id="ai-status-card">
                <div class="ai-status-empty">
                    <span class="ai-status-empty-icon">üìä</span>
                    <p>No analysis yet. Click the button above to get started!</p>
                </div>
            </div>
            
            <!-- Loading/Results Container -->
            <div id="ai-loading-container"></div>
            
            <!-- Results Display (for future use) -->
            <div id="ai-results"></div>
            
            <!-- History Preview -->
            <div id="ai-history-preview"></div>
        </div>
    </div>
    
    <!-- History Tab -->
    <div data-tab-content="history" style="
        display: none; 
        padding: 15px; 
        overflow-y: auto; 
        overflow-x: hidden;
        height: calc(100vh - 165px);
        -webkit-overflow-scrolling: touch;
    ">
        <div id="history-container"></div>
    </div>
    
    <script>
        // Initialize Telegram WebApp
        const tg = window.Telegram.WebApp;
        
        console.log('=== CHART INITIALIZATION START ===');
        console.log('Telegram WebApp:', tg);
        console.log('LightweightCharts available:', typeof LightweightCharts !== 'undefined');
        console.log('Platform:', tg.platform);
        console.log('Version:', tg.version);
        
        // Check if LightweightCharts is loaded
        if (typeof LightweightCharts === 'undefined') {
            console.error('‚ùå LightweightCharts library not loaded!');
            document.getElementById('loading').innerHTML = `
                <div style="color: red; padding: 20px; text-align: center;">
                    <h3>‚ö†Ô∏è Error Loading Chart Library</h3>
                    <p>LightweightCharts failed to load</p>
                    <button onclick="location.reload()">Reload</button>
                </div>
            `;
            throw new Error('LightweightCharts not loaded');
        }
        
        // Configure WebApp (Best Practices from docs)
        tg.ready();  // Signal that Mini App is ready
        tg.expand();  // Expand to maximum height
        
        // Enable vertical swipes (recommended by docs)
        if (tg.isVersionAtLeast('7.7')) {
            tg.enableVerticalSwipes();
        }
        
        // Apply Telegram theme
        if (tg.colorScheme === 'dark') {
            document.body.style.background = '#1a1a1a';
        }
        
        // Tab navigation will be handled by NavigationController (js/navigation.js)
        // Keeping this comment for reference - inline code removed to avoid conflicts
        
        // Get parameters from URL
        const urlParams = new URLSearchParams(window.location.search);
        let symbol = urlParams.get('symbol') || 'BTCUSDT';
        const initialTimeframe = urlParams.get('timeframe') || '1h';
        const aiAnalysis = urlParams.get('ai_analysis');  // Optional AI analysis data
        
        // Set initial symbol in dropdown
        const symbolSelect = document.getElementById('symbol-select');
        const customSymbolInput = document.getElementById('custom-symbol-input');
        const applyCustomBtn = document.getElementById('apply-custom-symbol');
        
        // Check if current symbol is in the predefined list
        const predefinedSymbols = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT', 'DOGEUSDT', 
                                    'ADAUSDT', 'AVAXUSDT', 'DOTUSDT', 'MATICUSDT', 'LINKUSDT', 
                                    'UNIUSDT', 'ATOMUSDT', 'LTCUSDT', 'ETCUSDT'];
        
        if (symbolSelect) {
            if (predefinedSymbols.includes(symbol)) {
                symbolSelect.value = symbol;
            } else {
                // Custom symbol from URL
                symbolSelect.value = 'CUSTOM';
                customSymbolInput.style.display = 'block';
                applyCustomBtn.style.display = 'block';
                customSymbolInput.value = symbol;
            }
            
            // Handle dropdown change
            symbolSelect.addEventListener('change', (e) => {
                const selectedValue = e.target.value;
                
                if (selectedValue === 'CUSTOM') {
                    // Show custom input
                    customSymbolInput.style.display = 'block';
                    applyCustomBtn.style.display = 'block';
                    customSymbolInput.focus();
                    
                    // Haptic feedback
                    if (tg.HapticFeedback) {
                        tg.HapticFeedback.impactOccurred('light');
                    }
                } else {
                    // Hide custom input and switch symbol
                    customSymbolInput.style.display = 'none';
                    applyCustomBtn.style.display = 'none';
                    
                    if (selectedValue !== symbol) {
                        switchSymbol(selectedValue);
                    }
                }
            });
            
            // Handle custom symbol apply button
            applyCustomBtn.addEventListener('click', async () => {
                let customSymbol = customSymbolInput.value.trim().toUpperCase();
                
                if (!customSymbol) {
                    if (tg.showAlert) {
                        tg.showAlert('‚ö†Ô∏è Vui l√≤ng nh·∫≠p symbol (VD: PEPE, BTC, ETH)');
                    }
                    return;
                }
                
                // Auto-append USDT if not present
                if (!customSymbol.endsWith('USDT')) {
                    customSymbol = customSymbol + 'USDT';
                }
                
                // Switch to custom symbol
                await switchSymbol(customSymbol);
            });
            
            // Handle Enter key in custom input
            customSymbolInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    applyCustomBtn.click();
                }
            });
        }
        
        // Function to validate symbol exists on Binance
        async function validateSymbol(symbolToCheck) {
            try {
                // Use Binance 24hr ticker endpoint to check if symbol exists
                const checkUrl = `https://api.binance.com/api/v3/ticker/24hr?symbol=${symbolToCheck}`;
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                const response = await fetch(checkUrl, {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' },
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    const data = await response.json();
                    // Check if symbol is trading
                    if (data.symbol === symbolToCheck) {
                        console.log(`‚úÖ Symbol ${symbolToCheck} exists and is trading`);
                        return true;
                    }
                }
                
                console.warn(`‚ö†Ô∏è Symbol ${symbolToCheck} not found or not trading`);
                return false;
            } catch (error) {
                console.error(`‚ùå Error validating symbol ${symbolToCheck}:`, error.message);
                return false;
            }
        }
        
        // Function to switch symbol
        async function switchSymbol(newSymbol) {
            if (newSymbol === symbol) {
                console.log('Already on this symbol, skipping switch');
                return;
            }
            
            console.log(`üìä Attempting to switch to ${newSymbol}`);
            
            // Show loading immediately
            showLoading();
            
            // Validate symbol first
            const isValid = await validateSymbol(newSymbol);
            
            if (!isValid) {
                hideLoading();
                
                // Error haptic
                if (tg.HapticFeedback) {
                    tg.HapticFeedback.notificationOccurred('error');
                }
                
                // Show detailed error
                if (tg.showAlert) {
                    tg.showAlert(`‚ùå Symbol kh√¥ng h·ª£p l·ªá: ${newSymbol}\n\n` +
                        `Symbol n√†y kh√¥ng t·ªìn t·∫°i ho·∫∑c kh√¥ng ƒë∆∞·ª£c giao d·ªãch tr√™n Binance.\n\n` +
                        `G·ª£i √Ω:\n` +
                        `‚úì Ki·ªÉm tra ch√≠nh t·∫£ (VD: PEPE, DOGE, SHIB)\n` +
                        `‚úì ƒê·∫£m b·∫£o coin c√≥ tr√™n Binance Spot\n` +
                        `‚úì Th·ª≠ c√°c symbol ph·ªï bi·∫øn t·ª´ dropdown`);
                }
                
                // Reset to previous symbol
                customSymbolInput.style.display = 'none';
                applyCustomBtn.style.display = 'none';
                
                if (predefinedSymbols.includes(symbol)) {
                    symbolSelect.value = symbol;
                } else {
                    symbolSelect.value = 'BTCUSDT';
                    symbol = 'BTCUSDT';
                }
                
                return;
            }
            
            // Symbol is valid, proceed with switch
            symbol = newSymbol;
            console.log(`üìä Switching to validated symbol: ${symbol}`);
            
            // Haptic feedback
            if (tg.HapticFeedback) {
                tg.HapticFeedback.impactOccurred('medium');
            }
            
            // Close WebSocket if active
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            
            // Update header
            document.getElementById('symbol').textContent = `Binance Spot: ${symbol}`;
            
            try {
                // Reset fitContent flag for new symbol
                isFirstLoad = true;
                
                // Reload chart data
                await loadChartData(currentTimeframe);
                
                // Reconnect WebSocket with new symbol after data loads
                setTimeout(() => {
                    // Close existing WebSocket if any
                    if (ws) {
                        console.log('üîå Closing old WebSocket for symbol change...');
                        ws.close();
                        ws = null;
                    }
                    
                    // Clear reconnect timeout
                    if (wsReconnectTimeout) {
                        clearTimeout(wsReconnectTimeout);
                        wsReconnectTimeout = null;
                    }
                    
                    // Reset reconnect attempts
                    wsReconnectAttempts = 0;
                    
                    // Connect WebSocket with new symbol
                    if (typeof connectWebSocket === 'function') {
                        console.log(`üîÑ Reconnecting WebSocket for ${symbol}...`);
                        connectWebSocket();
                    }
                }, 1000); // Wait 1s for chart data to fully load
                
                hideLoading();
                
                // Success haptic
                if (tg.HapticFeedback) {
                    tg.HapticFeedback.notificationOccurred('success');
                }
                
                // Update indicators tab with new symbol
                if (window.indicatorsTab && typeof window.indicatorsTab.setContext === 'function') {
                    console.log(`üìä Updating indicators tab for ${symbol}`);
                    window.indicatorsTab.setContext(symbol, currentTimeframe);
                }
                
                // Update custom input if needed
                if (!predefinedSymbols.includes(symbol)) {
                    customSymbolInput.value = symbol.replace('USDT', '');
                }
                customSymbolInput.style.display = 'none';
                applyCustomBtn.style.display = 'none';
                
            } catch (error) {
                hideLoading(); // Ensure loading is hidden on error
                console.error('Error switching symbol:', error);
                
                // Error haptic
                if (tg.HapticFeedback) {
                    tg.HapticFeedback.notificationOccurred('error');
                }
                
                // Show error
                if (tg.showAlert) {
                    tg.showAlert(`‚ùå Kh√¥ng th·ªÉ t·∫£i ${symbol}\n\nL·ªói: ${error.message}\n\nVui l√≤ng ki·ªÉm tra symbol c√≥ t·ªìn t·∫°i tr√™n Binance kh√¥ng.`);
                }
                
                // Revert to BTCUSDT on error
                symbol = 'BTCUSDT';
                symbolSelect.value = 'BTCUSDT';
                document.getElementById('symbol').textContent = `Binance Spot: ${symbol}`;
                
                try {
                    await loadChartData(currentTimeframe);
                    hideLoading();
                } catch (revertError) {
                    hideLoading(); // Ensure loading is hidden even if revert fails
                    console.error('Error reverting to BTCUSDT:', revertError);
                }
            }
        }
        
        // Load AI analysis if provided
        if (aiAnalysis) {
            try {
                const decodedAnalysis = decodeURIComponent(aiAnalysis);
                const aiContentEl = document.getElementById('ai-content');
                const aiLoadingEl = document.getElementById('ai-loading');
                if (aiContentEl && aiLoadingEl) {
                    aiLoadingEl.style.display = 'none';
                    aiContentEl.innerHTML = decodedAnalysis;
                }
            } catch (e) {
                console.error('Failed to load AI analysis:', e);
            }
        }
        
        // OLD AI BUTTON HANDLER - REMOVED
        // Now handled by AITabController in ai-tab.js
        console.log('‚ÑπÔ∏è AI tab now uses AITabController module');
        
        // Format AI analysis for display
        /**
         * Convert Telegram HTML to browser-safe HTML
         * @param {string} telegramHtml - HTML formatted for Telegram
         * @returns {string} Browser-safe HTML
         */
        function convertTelegramHTML(telegramHtml) {
            if (!telegramHtml) return '';
            
            // Replace Telegram HTML tags with browser equivalents
            let html = telegramHtml
                // Bold
                .replace(/<b>/g, '<strong>')
                .replace(/<\/b>/g, '</strong>')
                // Italic
                .replace(/<i>/g, '<em>')
                .replace(/<\/i>/g, '</em>')
                // Code
                .replace(/<code>/g, '<code style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px; font-family: monospace;">')
                // Preserve line breaks
                .replace(/\n/g, '<br>');
            
            return html;
        }
        
        function formatAIAnalysis(analysis) {
            const rec = analysis.recommendation || 'NEUTRAL';
            const conf = analysis.confidence || 0;
            const entry = analysis.entry_point || 0;
            const stop = analysis.stop_loss || 0;
            const targets = analysis.take_profit || [];
            const risk = analysis.risk_level || 'MEDIUM';
            
            // Use formatted messages if available (these are HTML formatted for Telegram)
            let reasoning = analysis.messages?.reasoning 
                || analysis.reasoning_vietnamese 
                || analysis.reasoning 
                || 'Kh√¥ng c√≥ ph√¢n t√≠ch chi ti·∫øt.';
            
            let technicalAnalysis = analysis.messages?.technical || '';
            
            // Convert Telegram HTML to browser HTML
            reasoning = convertTelegramHTML(reasoning);
            technicalAnalysis = convertTelegramHTML(technicalAnalysis);
            
            const recEmoji = rec === "BUY" ? "üü¢" : rec === "SELL" ? "üî¥" : rec === "WAIT" ? "üü°" : "‚ö™";
            const recColor = rec === "BUY" ? "#26A69A" : rec === "SELL" ? "#EF5350" : rec === "WAIT" ? "#FFA726" : "#787B86";
            
            let html = `
                <div class="ai-section">
                    <div class="ai-title" style="font-size: 20px; font-weight: 700;">üíé ${symbol}</div>
                    <div style="display: flex; align-items: center; gap: 16px; margin: 20px 0;">
                        <div style="font-size: 48px;">${recEmoji}</div>
                        <div>
                            <div style="font-size: 28px; font-weight: 700; color: ${recColor};">${rec}</div>
                            <div style="font-size: 16px; color: #787B86;">Confidence: ${conf}%</div>
                        </div>
                    </div>
                </div>
                
                <div class="ai-section">
                    <div class="ai-title" style="font-size: 18px; font-weight: 700;">üí∞ Trading Plan</div>
                    <div style="line-height: 2; font-size: 15px;">
                        <div style="margin: 8px 0;"><strong>Entry Point:</strong> <span style="color: #2962FF;">$${formatPrice(entry)}</span></div>
                        <div style="margin: 8px 0;"><strong>Stop Loss:</strong> <span style="color: #EF5350;">$${formatPrice(stop)}</span></div>
                        <div style="margin: 12px 0;"><strong>Take Profit:</strong></div>
                        <ul style="margin: 8px 0 0 24px; font-size: 15px;">
                            ${targets.map((tp, i) => `<li style="margin: 6px 0;">TP${i+1}: <span style="color: #26A69A;">$${formatPrice(tp)}</span></li>`).join('')}
                        </ul>
                        <div style="margin: 12px 0;"><strong>Risk Level:</strong> <span style="color: ${risk === 'HIGH' ? '#EF5350' : risk === 'LOW' ? '#26A69A' : '#FFA726'};">${risk}</span></div>
                    </div>
                </div>`;
            
            // Add technical analysis section if available
            if (technicalAnalysis && technicalAnalysis.length > 50) {
                html += `
                <div class="ai-section" style="max-height: 450px; overflow-y: auto; -webkit-overflow-scrolling: touch;">
                    <div class="ai-title" style="font-size: 18px; font-weight: 700;">üìä Ph√¢n t√≠ch K·ªπ thu·∫≠t chi ti·∫øt</div>
                    <div style="line-height: 1.8; font-size: 15px; padding: 4px 0;">${technicalAnalysis}</div>
                </div>`;
            }
            
            // Add reasoning section
            html += `
                <div class="ai-section" style="max-height: 550px; overflow-y: auto; -webkit-overflow-scrolling: touch;">
                    <div class="ai-title" style="font-size: 18px; font-weight: 700;">üß† AI Reasoning</div>
                    <div style="line-height: 1.8; font-size: 15px; padding: 4px 0;">${reasoning}</div>
                </div>
                
                <div style="text-align: center; color: #787B86; font-size: 13px; margin-top: 20px; padding: 16px; border-top: 1px solid rgba(255,255,255,0.1); line-height: 1.6;">
                    ‚ö†Ô∏è This is AI analysis, not financial advice.<br>
                    Always DYOR (Do Your Own Research) before investing.
                </div>
            `;
            
            return html;
        }
        
        /**
         * Display AI Analysis results in the WebApp
         * @param {Object} analysis - Analysis data from API
         * @param {HTMLElement} container - Container element to display in
         */
        function displayAIAnalysis(analysis, container) {
            if (!container) return;
            
            try {
                // Format using existing formatAIAnalysis function
                const formattedHtml = formatAIAnalysis(analysis);
                
                // Display with smooth transition
                container.style.opacity = '0';
                container.innerHTML = `
                    <div style="padding: 20px; animation: fadeIn 0.3s ease-in;">
                        ${formattedHtml}
                        <div style="text-align: center; margin-top: 24px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
                            <div style="color: #26A69A; font-size: 15px; margin-bottom: 12px; font-weight: 500;">
                                ‚úÖ Analysis also sent to your Telegram chat
                            </div>
                            <button id="close-analysis-btn" style="
                                background: rgba(255,255,255,0.1);
                                border: 1px solid rgba(255,255,255,0.2);
                                color: white;
                                padding: 12px 32px;
                                border-radius: 10px;
                                cursor: pointer;
                                font-size: 16px;
                                font-weight: 600;
                                transition: all 0.2s;
                            " onmouseover="this.style.background='rgba(255,255,255,0.2)'" 
                               onmouseout="this.style.background='rgba(255,255,255,0.1)'">
                                Close
                            </button>
                        </div>
                    </div>
                `;
                
                // Fade in animation
                setTimeout(() => {
                    container.style.opacity = '1';
                    container.style.transition = 'opacity 0.3s ease-in';
                }, 10);
                
                // Close button handler
                const closeBtn = container.querySelector('#close-analysis-btn');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        container.innerHTML = `
                            <div style="text-align: center; color: #787B86; padding: 40px 20px;">
                                <div style="font-size: 64px; margin-bottom: 20px;">ü§ñ</div>
                                <div style="font-size: 17px; line-height: 1.6;">Click "Analyze with Gemini AI" to get insights</div>
                            </div>
                        `;
                        
                        // Reset analyze button
                        const aiAnalyzeBtn = document.getElementById('ai-analyze-btn');
                        if (aiAnalyzeBtn) {
                            aiAnalyzeBtn.disabled = false;
                            aiAnalyzeBtn.innerHTML = 'üß† Analyze with Gemini AI';
                            aiAnalyzeBtn.style.background = 'linear-gradient(135deg, #2962FF 0%, #1E88E5 100%)';
                        }
                    });
                }
                
                console.log('‚úÖ AI Analysis displayed in WebApp');
                
            } catch (error) {
                console.error('‚ùå Error displaying AI analysis:', error);
                container.innerHTML = `
                    <div style="text-align: center; color: #EF5350; padding: 32px 24px;">
                        <div style="font-size: 20px; font-weight: 600; margin-bottom: 16px;">‚ùå Display Error</div>
                        <div style="color: #787B86; font-size: 15px; line-height: 1.6;">
                            Could not display analysis results.<br>
                            Check your Telegram chat for the full analysis.
                        </div>
                    </div>
                `;
            }
        }
        
        // Chart instance
        let chart = null;
        let candlestickSeries = null;
        let volumeSeries = null;
        let ema33Series = null;  // EMA 33 (short-term)
        let ema99Series = null;  // EMA 99 (medium-term)
        let ema144Series = null; // EMA 144 (long-term)
        let currentTimeframe = initialTimeframe;
        let isChartReady = false;
        let isFirstLoad = true;  // Track first load to only fitContent() once
        
        // WebSocket variables (global scope for access from loadChartData)
        let ws = null;
        let wsReconnectTimeout = null;
        let wsReconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;
        const RECONNECT_DELAY = 3000; // 3 seconds
        
        // Store latest data for indicator updates
        let latestData = {
            rsi: null,
            mfi: null,
            stochRSI: null,
            volumeRatio: null,
            signal: null,
            candles: [],
            high24h: null,
            low24h: null,
            volume24h: null
        };
        
        // Indicator thresholds (Matching Pine Script: rsi_lower=20, rsi_upper=80)
        const RSI_OVERSOLD = 20;
        const RSI_OVERBOUGHT = 80;
        const MFI_OVERSOLD = 20;
        const MFI_OVERBOUGHT = 80;
        
        // ============================================================
        // PRICE FORMATTING HELPERS (Phase 1: Professional Formatting)
        // ============================================================
        
        /**
         * Detect optimal precision based on price value (Phase 6: Refined)
         * @param {number} price - Price value
         * @returns {number} Precision (2-8 decimal places)
         */
        function detectPrecision(price) {
            if (!price || price === 0) return 2;
            
            const absPrice = Math.abs(price);
            
            // Phase 6: Refined precision logic
            if (absPrice >= 1000) return 2;      // BTC: $43,250.50
            if (absPrice >= 100) return 3;       // ETH: $3,526.440
            if (absPrice >= 10) return 4;        // BNB: $654.3210
            if (absPrice >= 1) return 5;         // ADA: $1.23450
            if (absPrice >= 0.1) return 6;       // DOGE: $0.123456
            if (absPrice >= 0.001) return 7;     // Small: $0.0123456
            return 8;                             // SHIB: $0.00001234
        }
        
        /**
         * Get user's locale (defaults to en-US)
         */
        function getUserLocale() {
            return window.navigator.languages?.[0] || 'en-US';
        }
        
        /**
         * Create price formatter with auto-precision
         */
        function createPriceFormatter(price) {
            const precision = detectPrecision(price);
            return new Intl.NumberFormat(getUserLocale(), {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: precision,
                maximumFractionDigits: precision
            });
        }
        
        /**
         * Format price with proper precision
         * @param {number} price - Price value
         * @returns {string} Formatted price like "$43,250.50"
         */
        function formatPrice(price) {
            if (!price || isNaN(price)) return '$0.00';
            
            try {
                const formatter = createPriceFormatter(price);
                return formatter.format(price);
            } catch (error) {
                console.error('Error formatting price:', error);
                return `$${price.toFixed(2)}`;
            }
        }
        
        /**
         * Format percentage with sign
         * @param {number} value - Percentage value (e.g., 0.0234 for 2.34%)
         * @returns {string} Formatted like "+2.34%" or "-1.56%"
         */
        function formatPercentage(value) {
            if (value === 0 || isNaN(value)) return '0.00%';
            
            try {
                const percentFormatter = new Intl.NumberFormat(getUserLocale(), {
                    style: 'percent',
                    signDisplay: 'always',  // Always show +/-
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
                return percentFormatter.format(value);
            } catch (error) {
                console.error('Error formatting percentage:', error);
                const sign = value >= 0 ? '+' : '';
                return `${sign}${(value * 100).toFixed(2)}%`;
            }
        }
        
        /**
         * Format volume with compact notation (K/M/B)
         * @param {number} volume - Volume value
         * @returns {string} Formatted like "1.23K" or "45.68M"
         */
        function formatVolume(volume) {
            if (!volume || volume === 0) return '0';
            
            try {
                const volumeFormatter = new Intl.NumberFormat(getUserLocale(), {
                    notation: 'compact',
                    compactDisplay: 'short',
                    maximumFractionDigits: 2
                });
                return volumeFormatter.format(volume);
            } catch (error) {
                console.error('Error formatting volume:', error);
                // Fallback to manual K/M/B
                if (volume >= 1e9) return (volume / 1e9).toFixed(2) + 'B';
                if (volume >= 1e6) return (volume / 1e6).toFixed(2) + 'M';
                if (volume >= 1e3) return (volume / 1e3).toFixed(2) + 'K';
                return volume.toFixed(0);
            }
        }
        
        // ============================================================
        // PRICE CHANGE UPDATER (Simplified - no OHLCV legend)
        // ============================================================
        
        /**
         * Update price change in header
         * @param {object} bar - Bar data {open, high, low, close}
         */
        function updatePriceChange(bar) {
            if (!bar) return;
            
            const priceChangeEl = document.getElementById('price-change');
            if (!priceChangeEl) return;
            
            // Calculate and display change
            const change = bar.close - bar.open;
            const changePercent = (change / bar.open) * 100;
            const changeText = `${change >= 0 ? '+' : ''}${formatPrice(Math.abs(change))} (${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(2)}%)`;
            
            priceChangeEl.textContent = changeText;
            priceChangeEl.className = change >= 0 ? 'price-up' : 'price-down';
        }
        
        // ============================================================
        // HAPTIC FEEDBACK
        // ============================================================
        
        // Haptic feedback helper (Best practice from docs)
        function hapticFeedback(type = 'light') {
            if (tg.HapticFeedback) {
                switch(type) {
                    case 'light':
                        tg.HapticFeedback.impactOccurred('light');
                        break;
                    case 'medium':
                        tg.HapticFeedback.impactOccurred('medium');
                        break;
                    case 'heavy':
                        tg.HapticFeedback.impactOccurred('heavy');
                        break;
                    case 'success':
                        tg.HapticFeedback.notificationOccurred('success');
                        break;
                    case 'error':
                        tg.HapticFeedback.notificationOccurred('error');
                        break;
                    case 'warning':
                        tg.HapticFeedback.notificationOccurred('warning');
                        break;
                }
            }
        }
        
        // Show toast notification
        function showToast(message, type = 'info') {
            // Create toast element
            const toast = document.createElement('div');
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed;
                top: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: ${type === 'success' ? 'rgba(76, 175, 80, 0.95)' : 
                             type === 'error' ? 'rgba(244, 67, 54, 0.95)' : 
                             type === 'warning' ? 'rgba(255, 152, 0, 0.95)' : 
                             'rgba(41, 98, 255, 0.95)'};
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                animation: slideDown 0.3s ease;
                max-width: 90%;
                text-align: center;
            `;
            
            document.body.appendChild(toast);
            
            // Auto remove after 3 seconds
            setTimeout(() => {
                toast.style.animation = 'slideUp 0.3s ease';
                setTimeout(() => {
                    document.body.removeChild(toast);
                }, 300);
            }, 3000);
        }
        
        // Add toast animations to CSS
        if (!document.getElementById('toast-animations')) {
            const style = document.createElement('style');
            style.id = 'toast-animations';
            style.textContent = `
                @keyframes slideDown {
                    from {
                        opacity: 0;
                        transform: translateX(-50%) translateY(-20px);
                    }
                    to {
                        opacity: 1;
                        transform: translateX(-50%) translateY(0);
                    }
                }
                @keyframes slideUp {
                    from {
                        opacity: 1;
                        transform: translateX(-50%) translateY(0);
                    }
                    to {
                        opacity: 0;
                        transform: translateX(-50%) translateY(-20px);
                    }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Get theme colors from Telegram
        function getThemeColors() {
            const theme = tg.themeParams;
            return {
                background: theme.bg_color || '#1a1a1a',
                textColor: theme.text_color || '#d1d4dc',
                gridColor: theme.hint_color || '#2a2a2a',
                upColor: '#26a69a',
                downColor: '#ef5350',
            };
        }
        
        // Initialize chart
        function initChart() {
            try {
                console.log('üìä Initializing chart...');
                const container = document.getElementById('chartContainer');
                
                if (!container) {
                    throw new Error('Chart container not found');
                }
                
                console.log('Container dimensions:', container.clientWidth, 'x', container.clientHeight);
                
                const colors = getThemeColors();
                console.log('Theme colors:', colors);
                
                console.log('Creating chart...');
                chart = LightweightCharts.createChart(container, {
                    width: container.clientWidth,
                    height: container.clientHeight,
                    layout: {
                        background: { 
                            type: 'solid',
                            color: '#131722'  // TradingView professional BG
                        },
                        textColor: '#D1D4DC',  // TradingView text
                        fontSize: 12,
                        fontFamily: '-apple-system, BlinkMacSystemFont, "SF Pro Display", "Trebuchet MS", Roboto, Ubuntu, sans-serif',
                    },
                    grid: {
                        vertLines: { 
                            color: '#363C4E',  // TradingView grid
                            style: 0,  // Solid
                            visible: true,
                        },
                        horzLines: { 
                            color: '#363C4E',
                            style: 0,
                            visible: true,
                        },
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                        vertLine: {
                            color: '#758696',  // TradingView professional crosshair
                            width: 1,
                            style: LightweightCharts.LineStyle.Dashed,  // Dashed line (Phase 4)
                            labelBackgroundColor: '#2962FF',  // TradingView blue
                            labelVisible: true,
                        },
                        horzLine: {
                            color: '#758696',  // TradingView professional crosshair
                            width: 1,
                            style: LightweightCharts.LineStyle.Dashed,  // Dashed line (Phase 4)
                            labelBackgroundColor: '#2962FF',  // TradingView blue
                            labelVisible: true,
                        },
                    },
                    rightPriceScale: {
                        borderColor: '#2A2E39',  // TradingView border
                        textColor: '#D1D4DC',
                        autoScale: true,  // Auto-adjust price scale to fit visible data
                        scaleMargins: {
                            top: 0.1,    // 10% margin at top
                            bottom: 0.2, // 20% margin at bottom (for volume)
                        },
                        mode: LightweightCharts.PriceScaleMode.Normal,  // Normal (not logarithmic)
                    },
                    timeScale: {
                        borderColor: '#2A2E39',
                        textColor: '#D1D4DC',
                        timeVisible: true,
                        secondsVisible: false,
                        rightOffset: 5,
                        barSpacing: 10,
                        minBarSpacing: 0.5,  // Allow maximum zoom in (0.5px per bar)
                        fixLeftEdge: false,  // Allow free horizontal panning
                        fixRightEdge: false,  // Allow free horizontal panning
                        lockVisibleTimeRangeOnResize: false,  // Allow flexible interaction
                        rightBarStaysOnScroll: false,  // Allow complete freedom to pan
                        shiftVisibleRangeOnNewBar: false,  // DON'T auto-scroll - let user control view
                    },
                    localization: {
                        // Apply professional price formatter
                        priceFormatter: (price) => formatPrice(price),
                    },
                    handleScroll: {
                        mouseWheel: true,
                        pressedMouseMove: true,
                        horzTouchDrag: true,  // Enable horizontal touch drag for panning timeline
                        vertTouchDrag: false,  // Disable to prevent conflict with page scroll
                    },
                    handleScale: {
                        axisPressedMouseMove: {
                            time: true,   // Allow dragging time scale
                            price: true,  // Allow dragging price scale
                        },
                        axisDoubleClickReset: {
                            time: true,   // Double-click to reset time scale
                            price: true,  // Double-click to reset price scale
                        },
                        mouseWheel: true,
                        pinch: true,  // Enable pinch zoom with 2 fingers
                    },
                    kineticScroll: {
                        touch: true,  // Enable smooth kinetic scrolling on mobile
                        mouse: false,
                    },
                });
            
            console.log('Adding candlestick series...');
            // TradingView professional candlestick colors
            candlestickSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
                upColor: '#26A69A',  // TradingView green (teal)
                downColor: '#EF5350',  // TradingView red
                borderUpColor: '#26A69A',
                borderDownColor: '#EF5350',
                wickUpColor: '#26A69A',
                wickDownColor: '#EF5350',
                borderVisible: false,
                priceFormat: {
                    type: 'price',
                    precision: 2,
                    minMove: 0.01,
                },
                priceScaleId: 'right',  // Use right price scale explicitly
                autoscaleInfoProvider: () => ({
                    priceRange: null,  // Let chart calculate based on visible data
                }),
            });
            console.log('Candlestick series added');
            
            console.log('Adding volume series...');
            volumeSeries = chart.addSeries(LightweightCharts.HistogramSeries, {
                color: '#26A69A',  // Match up candle color
                priceFormat: {
                    type: 'volume',
                },
                priceScaleId: '',
            });
            console.log('Volume series added');
            
            // Apply K/M/B formatting to volume axis (Phase 3)
            volumeSeries.priceScale().applyOptions({
                scaleMargins: {
                    top: 0.8,
                    bottom: 0,
                },
            });
            
            // Override volume formatter with K/M/B notation
            volumeSeries.applyOptions({
                priceFormat: {
                    type: 'custom',
                    formatter: (volume) => formatVolume(volume),
                },
            });
            
            // ============================================================
            // ADD EMA SERIES (33, 99, 144)
            // ============================================================
            console.log('Adding EMA series...');
            
            // EMA 33 (Short-term) - Yellow
            ema33Series = chart.addSeries(LightweightCharts.LineSeries, {
                color: '#FFA726',  // Orange/Yellow
                lineWidth: 2,
                lineStyle: 0,  // Solid
                crosshairMarkerVisible: true,
                lastValueVisible: true,
                priceLineVisible: false,
                title: 'EMA 33',
                priceScaleId: 'right',  // Use same scale as candlesticks
            });
            
            // EMA 99 (Medium-term) - Purple
            ema99Series = chart.addSeries(LightweightCharts.LineSeries, {
                color: '#AB47BC',  // Purple
                lineWidth: 2,
                lineStyle: 0,  // Solid
                crosshairMarkerVisible: true,
                lastValueVisible: true,
                priceLineVisible: false,
                title: 'EMA 99',
                priceScaleId: 'right',  // Use same scale as candlesticks
            });
            
            // EMA 144 (Long-term) - Cyan
            ema144Series = chart.addSeries(LightweightCharts.LineSeries, {
                color: '#26C6DA',  // Cyan
                lineWidth: 2,
                lineStyle: 0,  // Solid
                crosshairMarkerVisible: true,
                lastValueVisible: true,
                priceLineVisible: false,
                title: 'EMA 144',
                priceScaleId: 'right',  // Use same scale as candlesticks
            });
            
            console.log('EMA series added');
            
            console.log('‚úÖ Chart initialized successfully');
            isChartReady = true;
            
            // Subscribe to crosshair move for interactive indicators (Best practice from docs)
            chart.subscribeCrosshairMove((param) => {
                if (param.time) {
                    const data = param.seriesData.get(candlestickSeries);
                    if (data) {
                        // Update price display with crosshair data
                        updatePrice(data.close, data.close - data.open);
                        
                        // Update OHLCV legend (Phase 2)
                        updatePriceChange(data);
                    }
                } else {
                    // Reset to latest when crosshair leaves
                    if (latestData.rsi !== null) {
                        updateIndicatorDisplay(
                            latestData.rsi, 
                            latestData.mfi, 
                            latestData.stochRSI || null, 
                            latestData.volumeRatio || null
                        );
                    }
                    
                    // No action needed when crosshair leaves
                }
            });
            
            // Subscribe to visible range changes
            let lastVisibleRange = null;
            chart.timeScale().subscribeVisibleTimeRangeChange((timeRange) => {
                // Debounce haptic feedback (Phase 5)
                if (timeRange && lastVisibleRange) {
                    const diff = Math.abs(
                        (timeRange.to - timeRange.from) - 
                        (lastVisibleRange.to - lastVisibleRange.from)
                    );
                    // Only trigger haptic if zoom changed significantly
                    if (diff > 100) {
                        hapticFeedback('light');  // Light haptic for zoom
                    }
                }
                lastVisibleRange = timeRange;
            });
            
            // ============================================================
            // MOBILE OPTIMIZATION - Use chart library's built-in touch handling
            // Removed custom touch handlers to prevent conflicts and auto-reset issues
            // LightweightCharts v5.0 has excellent mobile touch support out-of-the-box
            // ============================================================
            
            // Handle resize with debounce (Best practice from docs)
            let resizeTimeout;
            const handleResize = () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (chart && container && isChartReady) {
                        const width = container.clientWidth;
                        const height = container.clientHeight;
                        
                        console.log('Resizing chart to:', width, 'x', height);
                        
                        chart.applyOptions({
                            width: width,
                            height: height,
                        });
                        
                        // DON'T call fitContent() on resize - preserve user's zoom/pan state
                        // Only fitContent() on first load (handled in loadChartData)
                    }
                }, 150);
            };
            
            window.addEventListener('resize', handleResize);
            
            // ResizeObserver for more accurate resize detection (Best practice)
            if (typeof ResizeObserver !== 'undefined') {
                const resizeObserver = new ResizeObserver(entries => {
                    if (entries.length === 0) return;
                    handleResize();
                });
                resizeObserver.observe(container);
            }
            
            } catch (error) {
                console.error('‚ùå Error initializing chart:', error);
                console.error('Error stack:', error.stack);
                document.getElementById('loading').innerHTML = `
                    <div style="color: red; padding: 20px; text-align: center;">
                        <h3>‚ö†Ô∏è Chart Initialization Failed</h3>
                        <p>${error.message}</p>
                        <button onclick="location.reload()">Reload</button>
                    </div>
                `;
                throw error;
            }
        }
        
        // Calculate simple RSI (for display purposes)
        function calculateSimpleRSI(prices, period = 6) {
            if (prices.length < period + 1) return 50;
            
            let gains = 0;
            let losses = 0;
            
            // Calculate initial average gain/loss
            for (let i = prices.length - period; i < prices.length; i++) {
                const change = prices[i] - prices[i - 1];
                if (change > 0) gains += change;
                else losses += Math.abs(change);
            }
            
            const avgGain = gains / period;
            const avgLoss = losses / period;
            
            if (avgLoss === 0) return 100;
            
            const rs = avgGain / avgLoss;
            const rsi = 100 - (100 / (1 + rs));
            
            return Math.round(rsi * 100) / 100;
        }
        
        // Calculate Stochastic RSI (Investopedia formula with 6 periods)
        // Formula: StochRSI = (RSI - min[RSI]) / (max[RSI] - min[RSI]) * 100
        // Using 6 periods for both RSI and Stoch calculation
        function calculateStochRSI(prices, rsiPeriod = 6, stochPeriod = 6) {
            if (prices.length < rsiPeriod + stochPeriod) {
                console.warn('Not enough data for Stoch RSI, returning neutral 50');
                return 50;
            }
            
            // Calculate RSI values for the lookback period
            const rsiValues = [];
            for (let i = rsiPeriod; i < prices.length; i++) {
                const subset = prices.slice(i - rsiPeriod, i + 1);
                rsiValues.push(calculateSimpleRSI(subset, rsiPeriod));
            }
            
            if (rsiValues.length < stochPeriod) {
                console.warn('Not enough RSI values for Stoch calculation');
                return 50;
            }
            
            // Get the most recent stochPeriod RSI values
            const recentRSI = rsiValues.slice(-stochPeriod);
            const maxRSI = Math.max(...recentRSI);
            const minRSI = Math.min(...recentRSI);
            
            // Handle edge case where all RSI values are the same
            if (maxRSI === minRSI) {
                console.log('RSI range is 0, returning neutral 50');
                return 50;
            }
            
            // Current RSI is the most recent value
            const currentRSI = rsiValues[rsiValues.length - 1];
            
            // Stochastic RSI formula
            const stochRSI = ((currentRSI - minRSI) / (maxRSI - minRSI)) * 100;
            
            console.log(`Stoch RSI(${rsiPeriod},${stochPeriod}): Current RSI=${currentRSI.toFixed(2)}, Min=${minRSI.toFixed(2)}, Max=${maxRSI.toFixed(2)}, Result=${stochRSI.toFixed(2)}`);
            
            return Math.round(stochRSI * 100) / 100;
        }
        
        // Calculate simple MFI (Money Flow Index)
        // Formula from Investopedia: MFI = 100 - (100 / (1 + Money Flow Ratio))
        // Money Flow = Typical Price √ó Volume
        // Typical Price = (High + Low + Close) / 3
        function calculateSimpleMFI(candles, period = 6) {
            if (candles.length < period + 1) {
                console.warn('Not enough candles for MFI calculation, returning neutral 50');
                return 50;
            }
            
            let posFlow = 0;
            let negFlow = 0;
            
            // Calculate money flow for each period
            for (let i = candles.length - period; i < candles.length; i++) {
                // Validate candle data
                if (!candles[i] || !candles[i-1]) {
                    console.error('Invalid candle data at index', i);
                    continue;
                }
                
                // Calculate typical price (High + Low + Close) / 3
                const typicalPrice = (candles[i].high + candles[i].low + candles[i].close) / 3;
                const prevTypicalPrice = (candles[i-1].high + candles[i-1].low + candles[i-1].close) / 3;
                
                // Get volume (Binance returns volume, not 'value')
                const volume = candles[i].volume || 0;
                
                // Raw Money Flow = Typical Price √ó Volume
                const rawMoneyFlow = typicalPrice * volume;
                
                // Classify as positive or negative money flow based on price direction
                if (typicalPrice > prevTypicalPrice) {
                    posFlow += rawMoneyFlow;
                } else if (typicalPrice < prevTypicalPrice) {
                    negFlow += rawMoneyFlow;
                }
                // If equal, don't add to either (neutral)
            }
            
            // Handle edge cases
            if (posFlow === 0 && negFlow === 0) {
                console.warn('No money flow detected, returning neutral 50');
                return 50;
            }
            
            if (negFlow === 0) {
                console.log('Only positive money flow, returning 100 (max bullish)');
                return 100;
            }
            
            if (posFlow === 0) {
                console.log('Only negative money flow, returning 0 (max bearish)');
                return 0;
            }
            
            // Calculate Money Flow Ratio
            const moneyFlowRatio = posFlow / negFlow;
            
            // Calculate MFI using standard formula
            const mfi = 100 - (100 / (1 + moneyFlowRatio));
            
            console.log(`MFI(${period}): PosFlow=${posFlow.toFixed(2)}, NegFlow=${negFlow.toFixed(2)}, Ratio=${moneyFlowRatio.toFixed(2)}, MFI=${mfi.toFixed(2)}`);
            
            return Math.round(mfi * 100) / 100;
        }
        
        // ============================================================
        // SUPPORT/RESISTANCE & VOLUME PROFILE INDICATORS
        // ============================================================
        
        // Store S/R lines for cleanup
        let supportLine = null;
        let resistanceLine = null;
        
        // Calculate Support and Resistance levels (144-period)
        function calculateSupportResistance(candles, period = 144) {
            if (candles.length < period) {
                console.warn(`Not enough candles for S/R calculation (${candles.length}/${period})`);
                return null;
            }
            
            // Use last 144 candles
            const recentData = candles.slice(-period);
            
            // Extract highs and lows
            const highs = recentData.map(c => c.high);
            const lows = recentData.map(c => c.low);
            
            // Resistance = Maximum high in period
            const resistance = Math.max(...highs);
            
            // Support = Minimum low in period
            const support = Math.min(...lows);
            
            console.log(`üìä S/R(${period}): Support=${support.toFixed(2)}, Resistance=${resistance.toFixed(2)}`);
            
            return { support, resistance };
        }
        
        // Draw Support and Resistance lines on chart
        function drawSupportResistance(support, resistance) {
            if (!candlestickSeries || !support || !resistance) {
                console.warn('Cannot draw S/R: missing series or values');
                return;
            }
            
            try {
                // Remove existing S/R lines
                if (supportLine) {
                    candlestickSeries.removePriceLine(supportLine);
                    supportLine = null;
                }
                if (resistanceLine) {
                    candlestickSeries.removePriceLine(resistanceLine);
                    resistanceLine = null;
                }
                
                // Draw Support line (green, dashed)
                supportLine = candlestickSeries.createPriceLine({
                    price: support,
                    color: '#26A69A',
                    lineWidth: 2,
                    lineStyle: 2, // Dashed (LightweightCharts.LineStyle.Dashed = 2)
                    axisLabelVisible: true,
                    title: 'Support',
                });
                
                // Draw Resistance line (red, dashed)
                resistanceLine = candlestickSeries.createPriceLine({
                    price: resistance,
                    color: '#EF5350',
                    lineWidth: 2,
                    lineStyle: 2, // Dashed
                    axisLabelVisible: true,
                    title: 'Resistance',
                });
                
                console.log('‚úÖ S/R lines drawn successfully');
            } catch (error) {
                console.error('Error drawing S/R lines:', error);
            }
        }
        
        // Detect Fair Value Gaps (FVG) - Price gaps with no trading
        function detectFairValueGaps(candles, period = 144) {
            if (candles.length < period + 2) {
                console.warn(`Not enough candles for FVG detection (${candles.length}/${period + 2})`);
                return [];
            }
            
            const fvgs = [];
            const recentData = candles.slice(-period);
            
            // Need 3 consecutive candles to detect FVG
            for (let i = 2; i < recentData.length; i++) {
                const prev = recentData[i - 2];  // Candle before gap
                const curr = recentData[i - 1];  // Middle candle (ignored)
                const next = recentData[i];      // Candle after gap
                
                // Bullish FVG: prev.high < next.low (gap up, price jumped)
                // This indicates buying pressure, unfilled gap below
                if (prev.high < next.low) {
                    fvgs.push({
                        type: 'bullish',
                        top: next.low,
                        bottom: prev.high,
                        time: next.time,
                        midpoint: (next.low + prev.high) / 2
                    });
                }
                
                // Bearish FVG: prev.low > next.high (gap down, price dropped)
                // This indicates selling pressure, unfilled gap above
                if (prev.low > next.high) {
                    fvgs.push({
                        type: 'bearish',
                        top: prev.low,
                        bottom: next.high,
                        time: next.time,
                        midpoint: (prev.low + next.high) / 2
                    });
                }
            }
            
            console.log(`üìä Detected ${fvgs.length} FVG zones (${fvgs.filter(f => f.type === 'bullish').length} bullish, ${fvgs.filter(f => f.type === 'bearish').length} bearish)`);
            
            return fvgs;
        }
        
        // Draw Fair Value Gaps on chart (using price lines)
        function drawFairValueGaps(fvgs) {
            if (!candlestickSeries || !fvgs || fvgs.length === 0) {
                console.warn('Cannot draw FVG: missing series or no gaps');
                return;
            }
            
            try {
                // Remove existing FVG markers
                if (fvgMarkers.length > 0) {
                    fvgMarkers.forEach(marker => {
                        candlestickSeries.removePriceLine(marker.top);
                        candlestickSeries.removePriceLine(marker.bottom);
                    });
                    fvgMarkers = [];
                }
                
                // Draw only last 5 most recent FVGs to avoid clutter
                const recentFVGs = fvgs.slice(-5);
                
                recentFVGs.forEach((fvg, index) => {
                    const color = fvg.type === 'bullish' ? '#26A69A' : '#EF5350';
                    const title = fvg.type === 'bullish' ? 'FVG‚Üë' : 'FVG‚Üì';
                    
                    // Draw top boundary (dotted)
                    const topLine = candlestickSeries.createPriceLine({
                        price: fvg.top,
                        color: color,
                        lineWidth: 1,
                        lineStyle: 3, // Dotted (LightweightCharts.LineStyle.Dotted = 3)
                        axisLabelVisible: false,
                        title: `${title} ${index + 1}`,
                    });
                    
                    // Draw bottom boundary (dotted)
                    const bottomLine = candlestickSeries.createPriceLine({
                        price: fvg.bottom,
                        color: color,
                        lineWidth: 1,
                        lineStyle: 3, // Dotted
                        axisLabelVisible: false,
                        title: '',
                    });
                    
                    // Store for cleanup
                    fvgMarkers.push({ top: topLine, bottom: bottomLine });
                });
                
                console.log(`‚úÖ Drew ${recentFVGs.length} FVG zones`);
            } catch (error) {
                console.error('Error drawing FVG zones:', error);
            }
        }
        
        // ============================================================
        // VWAP INDICATOR (Volume Weighted Average Price)
        // ============================================================
        
        // ============================================================
        // EMA CALCULATIONS (Exponential Moving Average)
        // ============================================================
        
        // Calculate EMA (Exponential Moving Average)
        // EMA formula: EMA = Price(t) √ó k + EMA(y) √ó (1 ‚àí k)
        // where k = 2 / (period + 1)
        function calculateEMA(prices, period) {
            if (!prices || prices.length < period) {
                console.warn(`Not enough data for EMA ${period}`);
                return [];
            }
            
            const k = 2 / (period + 1);
            const emaData = [];
            
            // First EMA is simple average
            let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
            emaData.push(ema);
            
            // Calculate subsequent EMAs
            for (let i = period; i < prices.length; i++) {
                ema = prices[i] * k + ema * (1 - k);
                emaData.push(ema);
            }
            
            return emaData;
        }
        
        // Update EMA series on chart
        function updateEMASeries(candles) {
            if (!candles || candles.length === 0) {
                console.warn('No candles for EMA calculation');
                return;
            }
            
            try {
                const closes = candles.map(c => c.close);
                const times = candles.map(c => c.time);
                
                // Calculate EMAs
                const ema33Values = calculateEMA(closes, 33);
                const ema99Values = calculateEMA(closes, 99);
                const ema144Values = calculateEMA(closes, 144);
                
                // Prepare data for chart (skip initial period where EMA not calculated)
                const ema33Data = times.slice(closes.length - ema33Values.length).map((time, i) => ({
                    time: time,
                    value: ema33Values[i]
                }));
                
                const ema99Data = times.slice(closes.length - ema99Values.length).map((time, i) => ({
                    time: time,
                    value: ema99Values[i]
                }));
                
                const ema144Data = times.slice(closes.length - ema144Values.length).map((time, i) => ({
                    time: time,
                    value: ema144Values[i]
                }));
                
                // Update series
                if (ema33Series && ema33Data.length > 0) {
                    ema33Series.setData(ema33Data);
                    console.log(`‚úÖ EMA 33 updated (${ema33Data.length} points)`);
                }
                
                if (ema99Series && ema99Data.length > 0) {
                    ema99Series.setData(ema99Data);
                    console.log(`‚úÖ EMA 99 updated (${ema99Data.length} points)`);
                }
                
                if (ema144Series && ema144Data.length > 0) {
                    ema144Series.setData(ema144Data);
                    console.log(`‚úÖ EMA 144 updated (${ema144Data.length} points)`);
                }
                
            } catch (error) {
                console.error('Error updating EMA series:', error);
            }
        }
        
        // Load chart data
        async function loadChartData(tf) {
            try {
                showLoading();
                
                console.log(`üìä Fetching data directly from Binance: ${symbol} ${tf}`);
                
                // Map timeframe to Binance interval
                const intervalMap = {
                    '5m': '5m',
                    '15m': '15m',
                    '1h': '1h',
                    '4h': '4h',
                    '1d': '1d'
                };
                const interval = intervalMap[tf] || '1h';
                
                // Try multiple Binance endpoints (with fallback to api1, api2, api3)
                const binanceEndpoints = [
                    'https://api.binance.com',
                    'https://api1.binance.com',
                    'https://api2.binance.com',
                    'https://api3.binance.com'
                ];
                
                let klines = null;
                let lastError = null;
                
                // Try each endpoint with exponential backoff
                for (let endpointIndex = 0; endpointIndex < binanceEndpoints.length && !klines; endpointIndex++) {
                    const baseUrl = binanceEndpoints[endpointIndex];
                    const binanceUrl = `${baseUrl}/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=1000`;
                    
                    console.log(`üîÑ Attempt ${endpointIndex + 1}/${binanceEndpoints.length}: ${baseUrl}`);
                    
                    // Retry with exponential backoff for each endpoint
                    let retries = 2;
                    for (let attempt = 0; attempt < retries && !klines; attempt++) {
                        try {
                            const controller = new AbortController();
                            const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout
                            
                            const response = await fetch(binanceUrl, {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json'
                                },
                                signal: controller.signal
                            });
                            
                            clearTimeout(timeoutId);
                            
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            
                            klines = await response.json();
                            console.log(`‚úÖ Success! Received ${klines.length} candles from ${baseUrl}`);
                            
                        } catch (fetchError) {
                            lastError = fetchError;
                            console.warn(`‚ö†Ô∏è Fetch failed (attempt ${attempt + 1}/${retries}):`, fetchError.message);
                            
                            // Exponential backoff: 500ms, 1000ms, 2000ms
                            if (attempt < retries - 1) {
                                const delay = 500 * Math.pow(2, attempt);
                                console.log(`‚è±Ô∏è Retrying in ${delay}ms...`);
                                await new Promise(resolve => setTimeout(resolve, delay));
                            }
                        }
                    }
                }
                
                // Validate data
                if (!klines || klines.length === 0) {
                    throw new Error(lastError ? 
                        `Failed to fetch data: ${lastError.message}` : 
                        'No candle data received from Binance'
                    );
                }
                
                // Convert Binance klines format to our format
                const candles = klines.map(k => ({
                    time: Math.floor(k[0] / 1000), // Convert ms to seconds
                    open: parseFloat(k[1]),
                    high: parseFloat(k[2]),
                    low: parseFloat(k[3]),
                    close: parseFloat(k[4]),
                    volume: parseFloat(k[5])
                }));
                
                console.log('Converted candles:', candles.length);
                console.log('First candle time:', new Date(candles[0].time * 1000).toISOString());
                console.log('Last candle time:', new Date(candles[candles.length - 1].time * 1000).toISOString());
                
                // Get current price (last close)
                const currentPrice = candles[candles.length - 1].close;
                const previousClose = candles[candles.length - 2]?.close || currentPrice;
                const priceChange = ((currentPrice - previousClose) / previousClose) * 100;
                
                // Calculate RSI and MFI (simple calculation for display)
                const closes = candles.map(c => c.close);
                const rsi = calculateSimpleRSI(closes, 6);
                
                // Calculate Stoch RSI (6 periods)
                const stochRSI = calculateStochRSI(closes, 6, 6);
                
                // Calculate MFI
                const mfi = calculateSimpleMFI(candles, 6);
                
                // Calculate volume ratio (current vs average)
                const volumes = candles.map(c => c.volume);
                const avgVolume = volumes.slice(0, -1).reduce((a, b) => a + b, 0) / (volumes.length - 1);
                const currentVolume = volumes[volumes.length - 1];
                const volumeRatio = currentVolume / avgVolume;
                
                console.log('Calculated RSI:', rsi, 'MFI:', mfi, 'Stoch RSI:', stochRSI, 'Volume Ratio:', volumeRatio.toFixed(2) + 'x');
                
                // Haptic feedback on success
                hapticFeedback('success');
                
                // Update header
                document.getElementById('symbol').textContent = `Binance Spot: ${symbol}`;
                updatePrice(currentPrice, priceChange);
                
                // Store latest data
                latestData.rsi = rsi;
                latestData.mfi = mfi;
                latestData.stochRSI = stochRSI;
                latestData.volumeRatio = volumeRatio;
                
                // Fetch 24h ticker data for additional stats
                try {
                    const ticker24hUrl = `https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`;
                    const ticker24hResponse = await fetch(ticker24hUrl);
                    if (ticker24hResponse.ok) {
                        const ticker24h = await ticker24hResponse.json();
                        
                        // Update 24h stats
                        const high24h = parseFloat(ticker24h.highPrice);
                        const low24h = parseFloat(ticker24h.lowPrice);
                        const volume24h = parseFloat(ticker24h.volume);
                        
                        document.getElementById('high-24h-value').textContent = `$${high24h.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 6})}`;
                        document.getElementById('low-24h-value').textContent = `$${low24h.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 6})}`;
                        document.getElementById('volume-24h-value').textContent = `${(volume24h).toFixed(2)}`;
                        
                        latestData.high24h = high24h;
                        latestData.low24h = low24h;
                        latestData.volume24h = volume24h;
                    }
                } catch (e) {
                    console.warn('Failed to fetch 24h ticker:', e);
                }
                
                // Update indicators with dynamic display
                updateIndicatorDisplay(rsi, mfi, stochRSI, volumeRatio);
                
                // Update mobile indicator panel
                if (typeof updateIndicatorPanel === 'function') {
                    updateIndicatorPanel({ rsi, mfi, stochRSI, volumeRatio });
                }
                
                // Update AI tab context
                if (window.aiTab) {
                    window.aiTab.setContext(symbol, tf);
                }
                
                // Update signal badge
                updateSignalBadge(rsi, mfi);
                
                // Update chart with data validation (Best practice from docs)
                // LightweightCharts REQUIRES sorted data by time (ascending)
                const sortedCandles = candles.sort((a, b) => a.time - b.time);
                
                // Remove duplicates (Best practice)
                const uniqueCandles = [];
                const seenTimes = new Set();
                for (const candle of sortedCandles) {
                    if (!seenTimes.has(candle.time)) {
                        uniqueCandles.push(candle);
                        seenTimes.add(candle.time);
                    }
                }
                
                console.log('Original candles:', sortedCandles.length);
                console.log('Unique candles:', uniqueCandles.length);
                
                // Validate OHLC data (Best practice)
                const candleData = uniqueCandles.map(c => {
                    const open = parseFloat(c.open);
                    const high = parseFloat(c.high);
                    const low = parseFloat(c.low);
                    const close = parseFloat(c.close);
                    
                    // Ensure high is highest and low is lowest
                    const validHigh = Math.max(open, high, low, close);
                    const validLow = Math.min(open, high, low, close);
                    
                    return {
                        time: c.time,  // Unix timestamp in seconds
                        open: open,
                        high: validHigh,
                        low: validLow,
                        close: close,
                    };
                });
                
                console.log('First candle:', candleData[0]);
                console.log('Last candle:', candleData[candleData.length - 1]);
                console.log('Data sorted, validated and formatted');
                
                const volumeData = uniqueCandles.map(c => ({
                    time: c.time,
                    value: parseFloat(c.volume),
                    color: c.close >= c.open ? '#26a69a80' : '#ef535080',
                }));
                
                // ============================================================
                // CLEAR OLD INDICATORS BEFORE LOADING NEW DATA
                // ============================================================
                console.log('Clearing old indicators...');
                
                // Clear S/R lines
                if (supportLine) {
                    try {
                        candlestickSeries.removePriceLine(supportLine);
                    } catch (e) { /* ignore */ }
                    supportLine = null;
                }
                if (resistanceLine) {
                    try {
                        candlestickSeries.removePriceLine(resistanceLine);
                    } catch (e) { /* ignore */ }
                    resistanceLine = null;
                }
                
                console.log('Setting candlestick data...');
                // Use setData for initial load, update() for real-time (Best practice)
                if (!candlestickSeries) {
                    console.error('‚ùå Candlestick series is null!');
                    throw new Error('Chart not initialized properly');
                }
                candlestickSeries.setData(candleData);
                console.log('Candlestick data set successfully');
                
                console.log('Setting volume data...');
                if (!volumeSeries) {
                    console.error('‚ùå Volume series is null!');
                    throw new Error('Chart not initialized properly');
                }
                volumeSeries.setData(volumeData);
                console.log('Volume data set successfully');
                
                // Store candles for indicators calculation (with volume for MFI)
                latestData.candles = candles.map(c => ({
                    time: c.time,
                    open: c.open,
                    high: c.high,
                    low: c.low,
                    close: c.close,
                    volume: c.volume  // Store as 'volume' for MFI calculation
                }));
                
                // ============================================================
                // DRAW INDICATORS: S/R, EMAs
                // ============================================================
                
                // Calculate and draw Support/Resistance levels (144 period)
                const srLevels = calculateSupportResistance(latestData.candles, 144);
                if (srLevels) {
                    drawSupportResistance(srLevels.support, srLevels.resistance);
                }
                
                // Update EMA series (33, 99, 144)
                updateEMASeries(latestData.candles);
                
                // Only fit content on first load or when explicitly needed
                // This prevents auto-reset when zooming/panning
                if (isFirstLoad) {
                    console.log('Fitting content (first load)...');
                    requestAnimationFrame(() => {
                        if (chart && isChartReady) {
                            chart.timeScale().fitContent();
                            console.log('Fit content completed');
                            isFirstLoad = false;  // Don't fit again unless explicitly reset
                        }
                    });
                } else {
                    console.log('Skipping fitContent to preserve user zoom/pan state');
                }
                
                console.log('‚úÖ Chart updated successfully');
                
                // DON'T reconnect WebSocket here - it causes constant reconnections
                // WebSocket connects once after initial load and auto-reconnects on close
                // See initialization section (line ~3210) for proper WebSocket setup
                
                // Smooth fade out loading
                setTimeout(() => {
                    hideLoading();
                }, 100);
                
            } catch (error) {
                hideLoading();
                console.error('Error loading chart data:', error);
                console.error('Error stack:', error.stack);
                
                // Haptic feedback on error
                hapticFeedback('error');
                
                // Show error to user
                if (tg.showAlert) {
                    tg.showAlert(`Error: ${error.message}`);
                } else {
                    showError(`Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu: ${error.message}`);
                }
            }
        }
        
        function updatePrice(price, change) {
            const priceEl = document.getElementById('price');
            // Use new formatPrice function with auto-precision
            priceEl.textContent = formatPrice(price);
            priceEl.className = change >= 0 ? 'price-up' : 'price-down';
        }
        
        // Update indicator display with dynamic colors and zones (Best practice)
        function updateIndicatorDisplay(rsi, mfi, stochRSI = null, volumeRatio = null) {
            // RSI(6)
            const rsiEl = document.getElementById('rsi-value');
            const rsiDot = document.getElementById('rsi-dot');
            
            rsiEl.textContent = rsi.toFixed(2);
            
            if (rsi < RSI_OVERSOLD) {
                rsiEl.className = 'indicator-value rsi-oversold';
                rsiDot.style.background = '#26A69A';
            } else if (rsi > RSI_OVERBOUGHT) {
                rsiEl.className = 'indicator-value rsi-overbought';
                rsiDot.style.background = '#EF5350';
            } else {
                rsiEl.className = 'indicator-value rsi-neutral';
                rsiDot.style.background = '#2962FF';
            }
            
            // MFI(6)
            const mfiEl = document.getElementById('mfi-value');
            const mfiDot = document.getElementById('mfi-dot');
            
            mfiEl.textContent = mfi.toFixed(2);
            
            if (mfi < MFI_OVERSOLD) {
                mfiEl.className = 'indicator-value mfi-oversold';
                mfiDot.style.background = '#26A69A';
            } else if (mfi > MFI_OVERBOUGHT) {
                mfiEl.className = 'indicator-value mfi-overbought';
                mfiDot.style.background = '#EF5350';
            } else {
                mfiEl.className = 'indicator-value mfi-neutral';
                mfiDot.style.background = '#FF6D00';
            }
            
            // Stoch RSI
            if (stochRSI !== null) {
                const stochRSIEl = document.getElementById('stoch-rsi-value');
                const stochRSIDot = document.getElementById('stoch-rsi-dot');
                
                stochRSIEl.textContent = stochRSI.toFixed(2);
                
                if (stochRSI < 20) {
                    stochRSIEl.className = 'indicator-value rsi-oversold';
                    stochRSIDot.style.background = '#26A69A';
                } else if (stochRSI > 80) {
                    stochRSIEl.className = 'indicator-value rsi-overbought';
                    stochRSIDot.style.background = '#EF5350';
                } else {
                    stochRSIEl.className = 'indicator-value rsi-neutral';
                    stochRSIDot.style.background = '#9C27B0';
                }
            }
            
            // Volume Ratio
            if (volumeRatio !== null) {
                const volumeEl = document.getElementById('volume-value');
                const volumeDot = document.getElementById('volume-dot');
                
                volumeEl.textContent = volumeRatio.toFixed(2) + 'x';
                
                if (volumeRatio > 1.5) {
                    volumeEl.className = 'indicator-value rsi-overbought';
                    volumeDot.style.background = '#EF5350';
                } else if (volumeRatio < 0.8) {
                    volumeEl.className = 'indicator-value mfi-neutral';
                    volumeDot.style.background = '#787B86';
                } else {
                    volumeEl.className = 'indicator-value rsi-neutral';
                    volumeDot.style.background = '#2962FF';
                }
            }
        }
        
        // Update signal badge based on RSI/MFI consensus (Best practice)
        function updateSignalBadge(rsi, mfi) {
            const signalBadge = document.getElementById('signal-badge');
            const signalText = document.getElementById('signal-text');
            
            // Determine signals
            let rsiSignal = 0;
            if (rsi < RSI_OVERSOLD) rsiSignal = 1;  // BUY
            else if (rsi > RSI_OVERBOUGHT) rsiSignal = -1;  // SELL
            
            let mfiSignal = 0;
            if (mfi < MFI_OVERSOLD) mfiSignal = 1;  // BUY
            else if (mfi > MFI_OVERBOUGHT) mfiSignal = -1;  // SELL
            
            // Consensus (both must agree)
            let finalSignal = 'NEUTRAL';
            let signalClass = 'signal-neutral';
            let arrow = '‚îÅ';
            
            if (rsiSignal === 1 && mfiSignal === 1) {
                finalSignal = 'BUY';
                signalClass = 'signal-buy';
                arrow = '‚Üë';
            } else if (rsiSignal === -1 && mfiSignal === -1) {
                finalSignal = 'SELL';
                signalClass = 'signal-sell';
                arrow = '‚Üì';
            }
            
            // Update badge
            signalBadge.className = `signal-badge ${signalClass}`;
            signalBadge.textContent = `${arrow} ${finalSignal}`;
            signalBadge.style.display = 'block';
            
            // Update signal text in indicators panel
            signalText.textContent = `${arrow} ${finalSignal}`;
            signalText.className = `indicator-value ${signalClass.replace('signal-', '')}`;
            
            // Store signal
            latestData.signal = finalSignal;
            
            // Haptic feedback on signal change
            if (finalSignal !== 'NEUTRAL') {
                hapticFeedback('success');
            }
        }
        
        function showLoading() {
            const loadingEl = document.getElementById('loading');
            loadingEl.classList.remove('hidden');
            loadingEl.style.display = 'block';
        }
        
        function hideLoading() {
            const loadingEl = document.getElementById('loading');
            loadingEl.classList.add('hidden');
            setTimeout(() => {
                loadingEl.style.display = 'none';
            }, 300);
        }
        
        function showError(message) {
            const errorEl = document.getElementById('error');
            errorEl.innerHTML = `
                <div style="text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 16px;">‚ö†Ô∏è</div>
                    <div style="font-size: 18px; font-weight: 600; margin-bottom: 12px;">Chart Load Error</div>
                    <div style="font-size: 14px; margin-bottom: 20px;">${message}</div>
                    <button onclick="location.reload()" style="
                        background: #2962FF;
                        color: white;
                        border: none;
                        padding: 12px 24px;
                        border-radius: 8px;
                        font-size: 14px;
                        font-weight: 600;
                        cursor: pointer;
                        box-shadow: 0 2px 8px rgba(41, 98, 255, 0.3);
                    ">üîÑ Retry</button>
                </div>
            `;
            errorEl.style.display = 'block';
            
            // Auto retry after 5 seconds
            setTimeout(() => {
                console.log('Auto retrying...');
                location.reload();
            }, 5000);
        }
        
        // Timeframe buttons
        document.querySelectorAll('.tf-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                try {
                    console.log('Timeframe button clicked:', btn.dataset.tf);
                    
                    // Haptic feedback
                    hapticFeedback('light');
                    
                    document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    currentTimeframe = btn.dataset.tf;
                    isFirstLoad = true;  // Reset to allow fitContent on timeframe change
                    console.log('Loading data for timeframe:', currentTimeframe);
                    loadChartData(currentTimeframe);
                } catch (error) {
                    console.error('Error in timeframe button click:', error);
                }
            });
        });
        
        // Double-tap to reset zoom (Best practice from mobile examples)
        let lastTapTime = 0;
        let tapTimeout;
        document.getElementById('chartContainer').addEventListener('touchend', (e) => {
            const currentTime = Date.now();
            const tapGap = currentTime - lastTapTime;
            
            clearTimeout(tapTimeout);
            
            if (tapGap < 300 && tapGap > 0) {
                // Double tap detected
                console.log('Double tap - resetting zoom');
                if (chart && isChartReady) {
                    // Smooth animation
                    requestAnimationFrame(() => {
                        chart.timeScale().fitContent();
                    });
                    hapticFeedback('medium');
                }
                lastTapTime = 0; // Reset to prevent triple-tap
            } else {
                // Single tap - set timer
                tapTimeout = setTimeout(() => {
                    lastTapTime = 0;
                }, 300);
                lastTapTime = currentTime;
            }
        });
        
        // Theme change listener
        if (tg.onEvent) {
            tg.onEvent('themeChanged', () => {
                if (chart) {
                    const colors = getThemeColors();
                    chart.applyOptions({
                        layout: {
                            background: { 
                                type: 'solid',
                                color: colors.background 
                            },
                            textColor: colors.textColor,
                        },
                        grid: {
                            vertLines: { color: colors.gridColor },
                            horzLines: { color: colors.gridColor },
                        }
                    });
                }
            });
        }
        
        // Viewport change listener
        if (tg.onEvent) {
            tg.onEvent('viewportChanged', (data) => {
                console.log('Viewport changed:', data);
                if (chart) {
                    const container = document.getElementById('chartContainer');
                    chart.applyOptions({
                        width: container.clientWidth,
                        height: container.clientHeight,
                    });
                    // DON'T call fitContent() - preserve user's zoom/pan state
                    // Only fitContent() on first load (handled in loadChartData)
                }
            });
            
            // Safe area change listeners (Bot API 8.0+)
            if (tg.isVersionAtLeast('8.0')) {
                tg.onEvent('safeAreaChanged', () => {
                    console.log('Safe area changed');
                    if (tg.safeAreaInset) {
                        const { top, bottom, left, right } = tg.safeAreaInset;
                        document.documentElement.style.setProperty('--tg-safe-area-inset-top', `${top}px`);
                        document.documentElement.style.setProperty('--tg-safe-area-inset-bottom', `${bottom}px`);
                        document.documentElement.style.setProperty('--tg-safe-area-inset-left', `${left}px`);
                        document.documentElement.style.setProperty('--tg-safe-area-inset-right', `${right}px`);
                    }
                });
                
                tg.onEvent('contentSafeAreaChanged', () => {
                    console.log('Content safe area changed');
                    if (tg.contentSafeAreaInset) {
                        const { top, bottom } = tg.contentSafeAreaInset;
                        document.documentElement.style.setProperty('--tg-content-safe-area-inset-top', `${top}px`);
                        document.documentElement.style.setProperty('--tg-content-safe-area-inset-bottom', `${bottom}px`);
                    }
                });
            }
        }
        
        // Apply safe area insets if available (Best practice from docs)
        if (tg.isVersionAtLeast('8.0')) {
            // Use safeAreaInset for system UI (notches, navigation bars)
            if (tg.safeAreaInset) {
                const { top, bottom, left, right } = tg.safeAreaInset;
                console.log('Safe area insets:', { top, bottom, left, right });
                document.documentElement.style.setProperty('--tg-safe-area-inset-top', `${top}px`);
                document.documentElement.style.setProperty('--tg-safe-area-inset-bottom', `${bottom}px`);
                document.documentElement.style.setProperty('--tg-safe-area-inset-left', `${left}px`);
                document.documentElement.style.setProperty('--tg-safe-area-inset-right', `${right}px`);
            }
            
            // Use contentSafeAreaInset for Telegram UI elements
            if (tg.contentSafeAreaInset) {
                const { top, bottom, left, right } = tg.contentSafeAreaInset;
                console.log('Content safe area insets:', { top, bottom, left, right });
                document.documentElement.style.setProperty('--tg-content-safe-area-inset-top', `${top}px`);
                document.documentElement.style.setProperty('--tg-content-safe-area-inset-bottom', `${bottom}px`);
            }
        }
        
        // Real-time update using series.update() (Best practice from docs)
        let lastUpdateData = null;
        
        async function updateRealtimeData() {
            if (!isChartReady || !candlestickSeries) return;
            
            try {
                // Fetch latest candle directly from Binance
                const intervalMap = {
                    '5m': '5m',
                    '15m': '15m',
                    '1h': '1h',
                    '4h': '4h',
                    '1d': '1d'
                };
                const interval = intervalMap[currentTimeframe] || '1h';
                const binanceUrl = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=1`;
                
                const response = await fetch(binanceUrl);
                if (!response.ok) return;
                
                const klines = await response.json();
                if (!klines || klines.length === 0) return;
                
                // Convert last candle
                const k = klines[0];
                const time = Math.floor(k[0] / 1000);
                const open = parseFloat(k[1]);
                const high = parseFloat(k[2]);
                const low = parseFloat(k[3]);
                const close = parseFloat(k[4]);
                const validHigh = Math.max(open, high, low, close);
                const validLow = Math.min(open, high, low, close);
                
                const newData = {
                    time: time,
                    open: open,
                    high: validHigh,
                    low: validLow,
                    close: close,
                };
                
                // Use update() for real-time, not setData() (Best practice)
                candlestickSeries.update(newData);
                
                // Update volume
                volumeSeries.update({
                    time: time,
                    value: parseFloat(lastCandle.volume),
                    color: close >= open ? '#26a69a80' : '#ef535080',
                });
                
                // Update price display
                updatePrice(data.currentPrice, data.priceChange);
                
                // Update price change in header
                updatePriceChange(newData);
                
                // Update indicators with dynamic display
                updateIndicatorDisplay(data.rsi, data.mfi);
                
                // Update signal badge
                updateSignalBadge(data.rsi, data.mfi);
                
                console.log('Real-time update completed');
                
            } catch (error) {
                console.error('Real-time update error:', error);
            }
        }
        
        // ============================================================
        // BINANCE WEBSOCKET REAL-TIME UPDATES (Phase 7: WebSocket)
        // ============================================================
        
        // WebSocket connection function (global scope)
        function connectWebSocket() {
            try {
                // Check if already connected - prevent duplicate connections
                if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) {
                    console.log('‚ö†Ô∏è WebSocket already connected or connecting, skipping...');
                    return;
                }
                
                // Close existing connection if any
                if (ws) {
                    console.log('Closing previous WebSocket connection...');
                    ws.close();
                    ws = null;
                }
                
                // Map timeframe to Binance WebSocket interval
                const intervalMap = {
                    '5m': '5m',
                    '15m': '15m',
                    '1h': '1h',
                    '4h': '4h',
                    '1d': '1d'
                };
                const wsInterval = intervalMap[currentTimeframe] || '1h';
                
                // Binance WebSocket endpoint for klines
                const wsUrl = `wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@kline_${wsInterval}`;
                    
                    console.log(`üîå Connecting to Binance WebSocket: ${wsUrl}`);
                    
                    ws = new WebSocket(wsUrl);
                    
                    ws.onopen = () => {
                        console.log('‚úÖ WebSocket connected');
                        wsReconnectAttempts = 0;
                        hapticFeedback('success');
                        
                        // Show connection indicator (optional)
                        const symbolEl = document.getElementById('symbol');
                        if (symbolEl) {
                            symbolEl.textContent = `${symbol} üü¢ Live`;
                        }
                    };
                    
                    // ============================================================
                    // OPTIMIZED WEBSOCKET MESSAGE HANDLING FOR MOBILE
                    // ============================================================
                    let pendingUpdate = null;
                    let updateScheduled = false;
                    
                    // Use requestAnimationFrame for smooth updates on mobile
                    function scheduleChartUpdate(candleData, volumeData) {
                        pendingUpdate = { candleData, volumeData };
                        
                        if (!updateScheduled) {
                            updateScheduled = true;
                            requestAnimationFrame(() => {
                                if (pendingUpdate && candlestickSeries && volumeSeries && isChartReady) {
                                    candlestickSeries.update(pendingUpdate.candleData);
                                    volumeSeries.update(pendingUpdate.volumeData);
                                }
                                updateScheduled = false;
                            });
                        }
                    }
                    
                    ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            
                            // Binance kline format
                            if (data.e === 'kline' && data.k) {
                                const kline = data.k;
                                
                                // Convert to chart format
                                const time = Math.floor(kline.t / 1000); // Convert ms to seconds
                                const open = parseFloat(kline.o);
                                const high = parseFloat(kline.h);
                                const low = parseFloat(kline.l);
                                const close = parseFloat(kline.c);
                                const volume = parseFloat(kline.v);
                                const isClosed = kline.x; // Is candle closed?
                                
                                // Validate OHLC
                                const validHigh = Math.max(open, high, low, close);
                                const validLow = Math.min(open, high, low, close);
                                
                                const candleData = {
                                    time: time,
                                    open: open,
                                    high: validHigh,
                                    low: validLow,
                                    close: close
                                };
                                
                                const volumeData = {
                                    time: time,
                                    value: volume,
                                    color: close >= open ? '#26a69a80' : '#ef535080'
                                };
                                
                                // Schedule optimized chart update using requestAnimationFrame
                                scheduleChartUpdate(candleData, volumeData);
                                
                                // Update price display immediately (lightweight operation)
                                const prevClose = latestData.candles.length > 0 
                                    ? latestData.candles[latestData.candles.length - 1].close 
                                    : close;
                                const priceChange = ((close - prevClose) / prevClose) * 100;
                                updatePrice(close, priceChange);
                                updatePriceChange(candleData);
                                
                                // Store latest candle with volume
                                const candleWithVolume = {
                                    time: time,
                                    open: open,
                                    high: validHigh,
                                    low: validLow,
                                    close: close,
                                    volume: volume  // Store volume for MFI calculation
                                };
                                latestData.candles.push(candleWithVolume);
                                if (latestData.candles.length > 500) {
                                    latestData.candles.shift(); // Keep last 500
                                }
                                
                                // Recalculate indicators on closed candles (only on candle close to save CPU)
                                if (isClosed) {
                                    const closes = latestData.candles.map(c => c.close);
                                    const rsi = calculateSimpleRSI(closes, 6);
                                    const stochRSI = calculateStochRSI(closes, 6, 6);
                                    const mfi = calculateSimpleMFI(latestData.candles, 6);  // Pass full candles array with volume
                                    
                                    // Calculate volume ratio
                                    const volumes = latestData.candles.map(c => c.volume || 0);
                                    const avgVolume = volumes.slice(0, -1).reduce((a, b) => a + b, 0) / (volumes.length - 1);
                                    const volumeRatio = volume / avgVolume;
                                    
                                    latestData.rsi = rsi;
                                    latestData.mfi = mfi;
                                    latestData.stochRSI = stochRSI;
                                    latestData.volumeRatio = volumeRatio;
                                    
                                    updateIndicatorDisplay(rsi, mfi, stochRSI, volumeRatio);
                                    updateSignalBadge(rsi, mfi);
                                    
                                    // Update mobile indicator panel
                                    if (typeof updateIndicatorPanel === 'function') {
                                        updateIndicatorPanel({ rsi, mfi, stochRSI, volumeRatio });
                                    }
                                    
                                    console.log(`üìä Candle closed: ${close}, RSI: ${rsi.toFixed(2)}, MFI: ${mfi.toFixed(2)}, StochRSI: ${stochRSI.toFixed(2)}, Vol: ${volumeRatio.toFixed(2)}x`);
                                }
                            }
                        } catch (error) {
                            console.error('WebSocket message parse error:', error);
                        }
                    };
                    
                    ws.onerror = (error) => {
                        console.error('‚ùå WebSocket error:', error);
                        
                        // Update connection indicator
                        const symbolEl = document.getElementById('symbol');
                        if (symbolEl) {
                            symbolEl.textContent = `${symbol} üî¥ Reconnecting...`;
                        }
                    };
                    
                    ws.onclose = () => {
                        console.log('üîå WebSocket closed');
                        
                        // Update connection indicator
                        const symbolEl = document.getElementById('symbol');
                        if (symbolEl) {
                            symbolEl.textContent = `${symbol} üü° Reconnecting...`;
                        }
                        
                        // Attempt reconnection with exponential backoff
                        if (wsReconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                            wsReconnectAttempts++;
                            const delay = RECONNECT_DELAY * Math.pow(2, wsReconnectAttempts - 1);
                            console.log(`üîÑ Reconnecting in ${delay}ms (attempt ${wsReconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
                            
                            wsReconnectTimeout = setTimeout(() => {
                                connectWebSocket();
                            }, delay);
                        } else {
                            console.error('‚ùå Max reconnection attempts reached');
                            const symbolEl = document.getElementById('symbol');
                            if (symbolEl) {
                                symbolEl.textContent = `${symbol} ‚ö†Ô∏è Disconnected`;
                            }
                            hapticFeedback('error');
                        }
                    };
                    
            } catch (error) {
                console.error('WebSocket connection error:', error);
            }
        }
        
        // ============================================================
        // INITIALIZATION
        // ============================================================
        
        // Initialize with error handling
        try {
            console.log('=== Starting chart initialization ===');
            initChart();
            console.log('=== Starting data load ===');
            loadChartData(currentTimeframe);
            
            // Start WebSocket connection after initial data load
            setTimeout(() => {
                connectWebSocket();
            }, 2000); // Wait 2s for initial data to load
            
            // NOTE: Timeframe change WebSocket reconnection is handled by
            // TimeframeSwitcher.onChange callback (see component initialization section)
            // Removed duplicate event listeners to prevent multiple reconnections
            
            // Cleanup WebSocket on page unload
            window.addEventListener('beforeunload', () => {
                if (ws) {
                    ws.close();
                }
                if (wsReconnectTimeout) {
                    clearTimeout(wsReconnectTimeout);
                }
            });
            
            // Fallback: HTTP polling for redundancy (every 30 seconds)
            let fallbackUpdateId = null;
            function startFallbackPolling() {
                fallbackUpdateId = setInterval(() => {
                    // Only poll if WebSocket is disconnected
                    if (!ws || ws.readyState !== WebSocket.OPEN) {
                        console.log('üì° Fallback polling update...');
                        updateRealtimeData();
                    }
                }, 30000); // 30 seconds
            }
            
            startFallbackPolling();
            
            // Cleanup fallback polling
            window.addEventListener('beforeunload', () => {
                if (fallbackUpdateId) {
                    clearInterval(fallbackUpdateId);
                }
            });
            
            console.log('=== Initialization complete ===');
        } catch (error) {
            console.error('=== FATAL ERROR ===', error);
            hapticFeedback('error');
            document.getElementById('loading').innerHTML = `
                <div style="color: red; padding: 20px; text-align: center;">
                    <h3>‚ö†Ô∏è Fatal Error</h3>
                    <p>${error.message}</p>
                    <pre style="font-size: 10px; text-align: left; background: #000; padding: 10px; overflow: auto;">${error.stack}</pre>
                    <button onclick="location.reload()" style="margin-top: 10px; padding: 10px 20px; font-size: 16px;">Reload</button>
                </div>
            `;
        }
    </script>
    
    <!-- Mobile Components -->
    <script src="js/navigation.js"></script>
    <script src="js/timeframe.js"></script>
    <script src="js/indicators.js"></script>
    <script src="js/ai-tab.js"></script>
    
    <!-- Component Initialization - Run immediately -->
    <script>
        console.log('üîß Component initialization script loaded');
        console.log('Document ready state:', document.readyState);
        
        // Function to initialize all mobile components
        function initializeMobileComponents() {
            console.log('üöÄ Initializing mobile components...');
            console.log('NavigationController:', typeof NavigationController);
            console.log('TimeframeSwitcher:', typeof TimeframeSwitcher);
            console.log('IndicatorPanel:', typeof IndicatorPanel);
            console.log('AITabController:', typeof AITabController);
            
            // Enable NavigationController (now supports 4 tabs)
            if (typeof NavigationController !== 'undefined') {
                try {
                    window.navigation = new NavigationController();
                    console.log('‚úÖ Navigation initialized (4 tabs via NavigationController)');
                } catch (e) {
                    console.error('‚ùå Navigation error:', e);
                }
            } else {
                console.log('‚ö†Ô∏è NavigationController not found, using fallback');
            }
            
            // Initialize AI Tab Controller
            if (window.aiTab) {
                try {
                    window.aiTab.init();
                    console.log('‚úÖ AI Tab initialized');
                    
                    // Update AI tab context when symbol/timeframe changes
                    if (typeof symbol !== 'undefined' && typeof currentTimeframe !== 'undefined') {
                        window.aiTab.setContext(symbol, currentTimeframe);
                    }
                } catch (e) {
                    console.error('‚ùå AI Tab initialization error:', e);
                }
            }
            
            // Initialize History Tab Controller
            if (typeof AnalysisHistory !== 'undefined' && tg.initDataUnsafe?.user?.id) {
                try {
                    window.historyTab = new AnalysisHistory(tg.initDataUnsafe.user.id);
                    console.log('‚úÖ History Tab instance created for user:', tg.initDataUnsafe.user.id);
                } catch (e) {
                    console.error('‚ùå History Tab initialization error:', e);
                }
            } else {
                if (typeof AnalysisHistory === 'undefined') console.warn('‚ö†Ô∏è AnalysisHistory class not found');
                if (!tg.initDataUnsafe?.user?.id) console.warn('‚ö†Ô∏è User ID not available');
            }
            
            // Initialize Indicators Tab Controller
            if (typeof IndicatorsTabController !== 'undefined') {
                try {
                    window.indicatorsTab = new IndicatorsTabController();
                    window.indicatorsTab.init();
                    console.log('‚úÖ Indicators Tab initialized');
                    
                    // Update indicators context when symbol/timeframe changes
                    if (typeof symbol !== 'undefined' && typeof currentTimeframe !== 'undefined') {
                        window.indicatorsTab.setContext(symbol, currentTimeframe);
                    }
                } catch (e) {
                    console.error('‚ùå Indicators Tab initialization error:', e);
                }
            } else {
                console.warn('‚ö†Ô∏è IndicatorsTabController class not found');
            }
            
            // Initialize Timeframe Switcher
            const timeframeContainer = document.querySelector('#timeframe-container');
            console.log('Timeframe container:', timeframeContainer);
            
            if (timeframeContainer && typeof TimeframeSwitcher !== 'undefined') {
                try {
                    window.timeframeSwitcher = new TimeframeSwitcher({
                        container: timeframeContainer,
                        defaultTimeframe: '1h',
                        onChange: (timeframe) => {
                            console.log('‚è±Ô∏è Timeframe changed:', timeframe);
                            
                            // Update current timeframe
                            if (typeof currentTimeframe !== 'undefined') {
                                currentTimeframe = timeframe;
                            }
                            
                            // Reload chart data with new timeframe
                            if (typeof loadChartData === 'function') {
                                loadChartData(timeframe);
                            }
                            
                            // Reconnect WebSocket with new timeframe after data loads
                            setTimeout(() => {
                                // Close existing WebSocket
                                if (ws) {
                                    console.log('üîå Closing WebSocket for timeframe change...');
                                    ws.close();
                                    ws = null;
                                }
                                
                                // Clear reconnect timeout
                                if (wsReconnectTimeout) {
                                    clearTimeout(wsReconnectTimeout);
                                    wsReconnectTimeout = null;
                                }
                                
                                // Reset reconnect attempts
                                wsReconnectAttempts = 0;
                                
                                // Reconnect with new timeframe
                                if (typeof connectWebSocket === 'function') {
                                    console.log('üîÑ Reconnecting WebSocket with new timeframe...');
                                    connectWebSocket();
                                }
                            }, 1000); // Wait 1s for chart data to load
                        }
                    });
                    console.log('‚úÖ Timeframe switcher initialized');
                } catch (e) {
                    console.error('‚ùå Timeframe error:', e);
                }
            } else {
                if (!timeframeContainer) console.warn('‚ö†Ô∏è Container not found');
                if (typeof TimeframeSwitcher === 'undefined') console.warn('‚ö†Ô∏è TimeframeSwitcher not found');
            }
            
            // Indicator Panel - DISABLED (using static tab view instead)
            // The drag panel is replaced with a simple tab view
            console.log('‚ÑπÔ∏è Indicator drag panel disabled - using tab view');
            
            console.log('üéâ Component initialization complete');
        }
        
        // Run immediately since we're at end of body
        initializeMobileComponents();
    </script>
</body>
</html>
