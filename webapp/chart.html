<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Live Chart</title>
    
    <!-- Telegram WebApp SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- Lightweight Charts Library v5.0 -->
    <script src="https://unpkg.com/lightweight-charts@5.0.0/dist/lightweight-charts.standalone.production.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            overflow: hidden;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        #loading.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        .spinner {
            border: 4px solid rgba(255,255,255,0.1);
            border-top: 4px solid #2196F3;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #header {
            background: #252525;
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
        }
        
        #symbol {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
        }
        
        #price {
            font-size: 16px;
            font-weight: 600;
        }
        
        .price-up { color: #26A69A; }
        .price-down { color: #EF5350; }
        
        #timeframes {
            background: #252525;
            padding: 8px;
            display: flex;
            gap: 8px;
            border-bottom: 1px solid #333;
            overflow-x: auto;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }
        
        #timeframes::-webkit-scrollbar {
            height: 4px;
        }
        
        #timeframes::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        #timeframes::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 2px;
        }
        
        .tf-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #333;
            color: #aaa;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .tf-btn:active {
            transform: scale(0.95);
        }
        
        .tf-btn.active {
            background: #2196F3;
            color: #fff;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.4);
        }
        
        .tf-btn:hover:not(.active) {
            background: #404040;
            color: #fff;
        }
        
        #chartContainer {
            width: 100%;
            height: calc(100vh - 110px);
            position: relative;
            touch-action: pan-x pan-y;
            -webkit-user-select: none;
            user-select: none;
        }
        
        #indicators {
            position: absolute;
            top: 120px;
            left: 10px;
            background: rgba(37, 37, 37, 0.9);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 10;
        }
        
        .indicator-row {
            display: flex;
            gap: 15px;
            margin: 4px 0;
        }
        
        .indicator-label {
            color: #aaa;
        }
        
        .indicator-value {
            font-weight: 600;
        }
        
        .rsi { color: #2962FF; }
        .mfi { color: #FF6D00; }
        
        #error {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #EF5350;
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            max-width: 80%;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div>Loading chart...</div>
    </div>
    
    <div id="error"></div>
    
    <div id="header">
        <div id="symbol">Loading...</div>
        <div id="price">--</div>
    </div>
    
    <div id="timeframes">
        <button class="tf-btn" data-tf="5m">5M</button>
        <button class="tf-btn active" data-tf="1h">1H</button>
        <button class="tf-btn" data-tf="4h">4H</button>
        <button class="tf-btn" data-tf="1d">1D</button>
    </div>
    
    <div id="indicators">
        <div class="indicator-row">
            <span class="indicator-label">RSI:</span>
            <span class="indicator-value rsi" id="rsi-value">--</span>
        </div>
        <div class="indicator-row">
            <span class="indicator-label">MFI:</span>
            <span class="indicator-value mfi" id="mfi-value">--</span>
        </div>
    </div>
    
    <div id="chartContainer"></div>
    
    <script>
        // Initialize Telegram WebApp
        const tg = window.Telegram.WebApp;
        tg.expand();
        tg.ready();
        
        console.log('=== CHART INITIALIZATION START ===');
        console.log('Telegram WebApp:', tg);
        console.log('LightweightCharts available:', typeof LightweightCharts !== 'undefined');
        
        // Check if LightweightCharts is loaded
        if (typeof LightweightCharts === 'undefined') {
            console.error('‚ùå LightweightCharts library not loaded!');
            document.getElementById('loading').innerHTML = `
                <div style="color: red; padding: 20px; text-align: center;">
                    <h3>‚ö†Ô∏è Error Loading Chart Library</h3>
                    <p>LightweightCharts failed to load</p>
                    <button onclick="location.reload()">Reload</button>
                </div>
            `;
            throw new Error('LightweightCharts not loaded');
        }
        
        // Apply Telegram theme
        if (tg.colorScheme === 'dark') {
            document.body.style.background = '#1a1a1a';
        }
        
        // Get parameters from URL
        const urlParams = new URLSearchParams(window.location.search);
        const symbol = urlParams.get('symbol') || 'BTCUSDT';
        const initialTimeframe = urlParams.get('timeframe') || '1h';
        
        // Chart instance
        let chart = null;
        let candlestickSeries = null;
        let volumeSeries = null;
        let currentTimeframe = initialTimeframe;
        
        // API endpoint (your bot's server)
        const API_BASE = window.location.origin;
        
        // Get theme colors from Telegram
        function getThemeColors() {
            const theme = tg.themeParams;
            return {
                background: theme.bg_color || '#1a1a1a',
                textColor: theme.text_color || '#d1d4dc',
                gridColor: theme.hint_color || '#2a2a2a',
                upColor: '#26a69a',
                downColor: '#ef5350',
            };
        }
        
        // Initialize chart
        function initChart() {
            try {
                console.log('üìä Initializing chart...');
                const container = document.getElementById('chartContainer');
                
                if (!container) {
                    throw new Error('Chart container not found');
                }
                
                console.log('Container dimensions:', container.clientWidth, 'x', container.clientHeight);
                
                const colors = getThemeColors();
                console.log('Theme colors:', colors);
                
                console.log('Creating chart...');
                chart = LightweightCharts.createChart(container, {
                    width: container.clientWidth,
                    height: container.clientHeight,
                    layout: {
                        background: { 
                            type: 'solid',
                            color: colors.background 
                        },
                        textColor: colors.textColor,
                    },
                    grid: {
                        vertLines: { color: colors.gridColor },
                        horzLines: { color: colors.gridColor },
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                    },
                    rightPriceScale: {
                        borderColor: colors.gridColor,
                    },
                    timeScale: {
                        borderColor: colors.gridColor,
                        timeVisible: true,
                        secondsVisible: false,
                        rightOffset: 5,
                        barSpacing: 10,
                        fixLeftEdge: false,
                        fixRightEdge: false,
                    },
                    handleScroll: {
                        mouseWheel: true,
                        pressedMouseMove: true,
                        horzTouchDrag: true,
                        vertTouchDrag: true,
                    },
                    handleScale: {
                        axisPressedMouseMove: true,
                        mouseWheel: true,
                        pinch: true,  // Enable pinch zoom for mobile
                    },
                });
            
            console.log('Adding candlestick series...');
            candlestickSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
                upColor: colors.upColor,
                downColor: colors.downColor,
                borderVisible: false,
                wickUpColor: colors.upColor,
                wickDownColor: colors.downColor,
            });
            console.log('Candlestick series added');
            
            console.log('Adding volume series...');
            volumeSeries = chart.addSeries(LightweightCharts.HistogramSeries, {
                color: '#26a69a',
                priceFormat: {
                    type: 'volume',
                },
                priceScaleId: '',
            });
            console.log('Volume series added');
            
            volumeSeries.priceScale().applyOptions({
                scaleMargins: {
                    top: 0.8,
                    bottom: 0,
                },
            });
            
            console.log('‚úÖ Chart initialized successfully');
            
            // Subscribe to visible range changes (for zoom/pan feedback)
            chart.timeScale().subscribeVisibleTimeRangeChange(() => {
                // Subtle haptic feedback on zoom/pan (very light)
                if (tg.HapticFeedback) {
                    tg.HapticFeedback.impactOccurred('light');
                }
            });
            
            // Handle resize with debounce
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (chart && container) {
                        chart.applyOptions({
                            width: container.clientWidth,
                            height: container.clientHeight,
                        });
                        chart.timeScale().fitContent();
                    }
                }, 100);
            });
            
            // Prevent default touch behaviors on chart container
            container.addEventListener('touchstart', (e) => {
                if (e.touches.length > 1) {
                    // Multi-touch (pinch zoom) - prevent default
                    e.preventDefault();
                }
            }, { passive: false });
            
            container.addEventListener('touchmove', (e) => {
                // Allow chart to handle all touch moves
                e.stopPropagation();
            }, { passive: true });
            
            } catch (error) {
                console.error('‚ùå Error initializing chart:', error);
                console.error('Error stack:', error.stack);
                document.getElementById('loading').innerHTML = `
                    <div style="color: red; padding: 20px; text-align: center;">
                        <h3>‚ö†Ô∏è Chart Initialization Failed</h3>
                        <p>${error.message}</p>
                        <button onclick="location.reload()">Reload</button>
                    </div>
                `;
                throw error;
            }
        }
        
        // Load chart data
        async function loadChartData(tf) {
            try {
                showLoading();
                
                console.log(`Fetching data: ${API_BASE}/api/chart?symbol=${symbol}&timeframe=${tf}`);
                
                // Fetch data from your backend
                const response = await fetch(`${API_BASE}/api/chart?symbol=${symbol}&timeframe=${tf}`);
                
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Error response:', errorText);
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();
                console.log('Received data:', data);
                console.log('Number of candles:', data.candles?.length);
                
                // Validate data
                if (!data.candles || data.candles.length === 0) {
                    throw new Error('No candle data received');
                }
                
                // Check timestamp format
                const firstTime = data.candles[0].time;
                console.log('First timestamp:', firstTime, typeof firstTime);
                
                // Validate timestamp is in seconds (not milliseconds)
                // Unix timestamp in seconds should be around 1.7 billion (year 2024)
                // Unix timestamp in milliseconds would be 1700+ billion
                if (firstTime > 10000000000) {
                    console.warn('Timestamp appears to be in milliseconds, converting to seconds');
                    // Convert all timestamps to seconds
                    data.candles.forEach(c => {
                        c.time = Math.floor(c.time / 1000);
                    });
                }
                
                // Haptic feedback on success
                hapticFeedback('success');
                
                // Update header
                document.getElementById('symbol').textContent = symbol;
                updatePrice(data.currentPrice, data.priceChange);
                
                // Update indicators
                document.getElementById('rsi-value').textContent = data.rsi.toFixed(2);
                document.getElementById('mfi-value').textContent = data.mfi.toFixed(2);
                
                // Update chart
                // LightweightCharts REQUIRES sorted data by time (ascending)
                const sortedCandles = data.candles.sort((a, b) => a.time - b.time);
                
                const candleData = sortedCandles.map(c => ({
                    time: c.time,  // Unix timestamp in seconds
                    open: parseFloat(c.open),
                    high: parseFloat(c.high),
                    low: parseFloat(c.low),
                    close: parseFloat(c.close),
                }));
                
                console.log('First candle:', candleData[0]);
                console.log('Last candle:', candleData[candleData.length - 1]);
                console.log('Data sorted and formatted');
                
                const volumeData = sortedCandles.map(c => ({
                    time: c.time,
                    value: parseFloat(c.volume),
                    color: c.close >= c.open ? '#26a69a80' : '#ef535080',
                }));
                
                console.log('Setting candlestick data...');
                candlestickSeries.setData(candleData);
                console.log('Candlestick data set successfully');
                
                console.log('Setting volume data...');
                volumeSeries.setData(volumeData);
                console.log('Volume data set successfully');
                
                console.log('Fitting content...');
                // Use smooth animation for fit
                requestAnimationFrame(() => {
                    chart.timeScale().fitContent();
                    console.log('Fit content completed');
                });
                
                console.log('‚úÖ Chart updated successfully');
                
                // Smooth fade out loading
                setTimeout(() => {
                    hideLoading();
                }, 100);
                
            } catch (error) {
                hideLoading();
                console.error('Error loading chart data:', error);
                console.error('Error stack:', error.stack);
                
                // Haptic feedback on error
                hapticFeedback('error');
                
                // Show error to user
                if (tg.showAlert) {
                    tg.showAlert(`Error: ${error.message}`);
                } else {
                    showError(`Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu: ${error.message}`);
                }
            }
        }
        
        function updatePrice(price, change) {
            const priceEl = document.getElementById('price');
            priceEl.textContent = `$${price.toLocaleString('en-US', {minimumFractionDigits: 2})}`;
            priceEl.className = change >= 0 ? 'price-up' : 'price-down';
        }
        
        function showLoading() {
            const loadingEl = document.getElementById('loading');
            loadingEl.classList.remove('hidden');
            loadingEl.style.display = 'block';
        }
        
        function hideLoading() {
            const loadingEl = document.getElementById('loading');
            loadingEl.classList.add('hidden');
            setTimeout(() => {
                loadingEl.style.display = 'none';
            }, 300);
        }
        
        function showError(message) {
            const errorEl = document.getElementById('error');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            setTimeout(() => {
                errorEl.style.display = 'none';
            }, 3000);
        }
        
        // Timeframe buttons
        document.querySelectorAll('.tf-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                try {
                    console.log('Timeframe button clicked:', btn.dataset.tf);
                    
                    // Haptic feedback
                    hapticFeedback('light');
                    
                    document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    currentTimeframe = btn.dataset.tf;
                    console.log('Loading data for timeframe:', currentTimeframe);
                    loadChartData(currentTimeframe);
                } catch (error) {
                    console.error('Error in timeframe button click:', error);
                }
            });
        });
        
        // Double-tap to reset zoom
        let lastTapTime = 0;
        document.getElementById('chartContainer').addEventListener('touchend', (e) => {
            const currentTime = new Date().getTime();
            const tapGap = currentTime - lastTapTime;
            
            if (tapGap < 300 && tapGap > 0) {
                // Double tap detected
                console.log('Double tap - resetting zoom');
                if (chart) {
                    chart.timeScale().fitContent();
                    hapticFeedback('medium');
                }
            }
            
            lastTapTime = currentTime;
        });
        
        // Theme change listener
        if (tg.onEvent) {
            tg.onEvent('themeChanged', () => {
                if (chart) {
                    const colors = getThemeColors();
                    chart.applyOptions({
                        layout: {
                            background: { 
                                type: 'solid',
                                color: colors.background 
                            },
                            textColor: colors.textColor,
                        },
                        grid: {
                            vertLines: { color: colors.gridColor },
                            horzLines: { color: colors.gridColor },
                        }
                    });
                }
            });
        }
        
        // Viewport change listener
        if (tg.onEvent) {
            tg.onEvent('viewportChanged', () => {
                if (chart) {
                    const container = document.getElementById('chartContainer');
                    chart.applyOptions({
                        width: container.clientWidth,
                        height: container.clientHeight,
                    });
                    chart.timeScale().fitContent();
                }
            });
        }
        
        // Apply safe area insets if available
        if (tg.safeAreaInset) {
            const { top, bottom } = tg.safeAreaInset;
            document.body.style.paddingTop = `${top}px`;
            document.body.style.paddingBottom = `${bottom}px`;
        }
        
        // Initialize with error handling
        try {
            console.log('=== Starting chart initialization ===');
            initChart();
            console.log('=== Starting data load ===');
            loadChartData(currentTimeframe);
            
            // Auto refresh every 30 seconds
            setInterval(() => {
                loadChartData(currentTimeframe);
            }, 30000);
            
            console.log('=== Initialization complete ===');
        } catch (error) {
            console.error('=== FATAL ERROR ===', error);
            document.getElementById('loading').innerHTML = `
                <div style="color: red; padding: 20px; text-align: center;">
                    <h3>‚ö†Ô∏è Fatal Error</h3>
                    <p>${error.message}</p>
                    <pre style="font-size: 10px; text-align: left; background: #000; padding: 10px; overflow: auto;">${error.stack}</pre>
                    <button onclick="location.reload()" style="margin-top: 10px; padding: 10px 20px; font-size: 16px;">Reload</button>
                </div>
            `;
        }
    </script>
</body>
</html>
